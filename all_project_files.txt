--- .\README.md ---

[![Discord](https://img.shields.io/discord/1054578014593241179?style=flat&logo=discord&logoColor=ffffff&label=Discord&labelColor=0000ff&link=https%3A%2F%2Fdiscord.gg%2FdzqeXYDDmy)](https://discord.gg/dzqeXYDDmy)

# Universal Discord Rich Presence

Welcome to **Universal Discord Rich Presence!** This project brings you an **automatic Rich Presence** (RPC) for Discord, displaying the current application you're using while your computer is on. It features full Discord integration with the **ability to rollback changes**, **an open-source codebase**, **automatic background updates**, and **minimal resource usage**. **No coding knowledge is required** to use this application. It is the first successful project for automatic RPC for Discord with an exceptional code structure and extensive application support.

## Requirements
- Python >= 3.11

## Setup
1. Ensure Python is installed.
2. Run `install` file to set up everything effortlessly.
3. If you encounter any issues or have questions, join our [Discord server](https://discord.gg/dzqeXYDDmy) and let us know where you need assistance.

## Features
- **Focused App Autodetection:** Automatically detects the focused application.
- **Instant Status Updates:** Changes your status as quickly as you switch between apps.
- **Full Discord Integration:** Seamlessly integrates with Discord.
- **Automatic Background Updates:** Keeps the application updated without manual intervention.
- **Minimal Resource Usage:** Consumes 0% CPU and only 25MB of RAM.
- **User-Friendly:** Requires no coding knowledge to use.
- **Expandable RPC Collection:** Easily add more Rich Presence configurations as needed.

## Plans
- [x] Complete the base collection.
- [x] Optimize the code for better performance.
- [x] Introduce more user-friendly customization and interaction options.
- [x] Add full integration in Discord.
- [x] Implement auto-updater.
- [ ] Fix minor bugs.

## Contributions and Support
If you'd like to suggest new features or improvements, feel free to:
- Join our [Discord server](https://discord.gg/dzqeXYDDmy) and share your ideas.
- Submit an [**issue**](https://github.com/Purple-Palm/Universal-Discord-Rich-Presence/issues) or a [**pull request**](https://github.com/Purple-Palm/Universal-Discord-Rich-Presence/pulls) on GitHub.

Your contributions and feedback are highly valued!

## Credits
This project includes code forked and adapted from [Colin Hartigan's project](https://github.com/colinhartigan/valorant-rpc). 

This project also includes code forked and adapted from [Haze's project](https://github.com/Its-Haze/league-rpc).

This project also includes code forked and adapted from [Dyl's project](https://github.com/kdouy/RobloxDiscordRPC).

We extend our gratitude for their amazing work.

### Version
Version: 7.0.0


--- .\presets\league-of-legends\exit.bat ---

@echo off
echo Starting exit.bat...
taskkill /F /IM python.exe /T
taskkill /F /IM pythonw.exe /T
taskkill /F /IM python3.11.exe /T
echo Current working directory: %cd%
cd ..
cd ..
call main-start.bat


pause


--- .\presets\league-of-legends\start.bat ---

@echo off
cd ..
cd ..
cd venv\Scripts
call activate.bat
cd ..\..
cd presets
cd league-of-legends
python __main__.py

pause


--- .\presets\league-of-legends\__main__.py ---

import argparse
import sys
import threading
import time
import os

import nest_asyncio  # type:ignore
import pypresence  # type:ignore
import psutil  # type:ignore
import win32gui  # type:ignore
import win32process  # type:ignore

from league_rpc.champion import gather_ingame_information, get_skin_asset
from league_rpc.gametime import get_current_ingame_time
from league_rpc.kda import get_creepscore, get_gold, get_kda, get_level
from league_rpc.lcu_api.lcu_connector import start_connector
from league_rpc.processes.process import (
    check_discord_process,
    check_league_client_process,
    player_state,
)
from league_rpc.reconnect import discord_reconnect_attempt
from league_rpc.utils.color import Color
from league_rpc.utils.const import (
    ALL_GAME_DATA_URL,
    CHAMPION_NAME_CONVERT_MAP,
    DEFAULT_CLIENT_ID,
    DEFAULT_LEAGUE_CLIENT_EXE_PATH,
    DISCORD_PROCESS_NAMES,
    LEAGUE_OF_LEGENDS_LOGO,
    SMALL_TEXT,
)
from league_rpc.utils.polling import wait_until_exists

# Discord Application: League of Linux


def get_active_window_executable():
    window = win32gui.GetForegroundWindow()
    _, pid = win32process.GetWindowThreadProcessId(window)

    try:
        process = psutil.Process(pid)
        return process.name()
    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess, Exception):
        return None


def check_focus_and_exit():
    if get_active_window_executable() != "LeagueOfLegends.exe":
        print(f"{Color.red}League of Legends is not the active window. Exiting...{Color.reset}")
        os.system("exit.bat")
        sys.exit()


def main(cli_args: argparse.Namespace) -> None:
    """
    This is the program that gets executed.
    """
    ############################################################
    ## Check Discord, RiotClient & LeagueClient processes     ##
    check_league_client_process(cli_args)

    rpc = check_discord_process(
        process_names=DISCORD_PROCESS_NAMES + cli_args.add_process,
        client_id=cli_args.client_id,
        wait_for_discord=cli_args.wait_for_discord,
    )

    # Start LCU_Thread
    # This process will connect to the LCU API and updates the rpc based on data subscribed from the LCU API.
    # In this case passing the rpc object to the process is easier than trying to return updated data from the process.
    # Every In-Client update will be handled by the LCU_Thread process and will update the rpc accordingly.
    lcu_process = threading.Thread(
        target=start_connector,
        args=(
            rpc,
            cli_args,
        ),
        daemon=True,
    )
    lcu_process.start()

    print(f"\n{Color.green}Successfully connected to Discord RPC!{Color.reset}")
    ############################################################

    start_time = int(time.time())
    while True:
        check_focus_and_exit()
        try:
            match player_state():
                case "InGame":
                    print(
                        f"\n{Color.dblue}Detected game! Will soon gather data and update discord RPC{Color.reset}"
                    )

                    # Poll the local league api until 200 response.
                    wait_until_exists(
                        url=ALL_GAME_DATA_URL,
                        custom_message="Failed to reach the local league api",
                        startup=True,
                    )
                    (
                        champ_name,
                        skin_name,
                        chroma_name,
                        skin_id,
                        gamemode,
                        _,
                        _,
                    ) = gather_ingame_information()
                    if gamemode == "TFT":
                        # TFT RPC
                        while player_state() == "InGame":
                            check_focus_and_exit()
                            try:
                                rpc.update(  # type:ignore
                                    large_image="https://wallpapercave.com/wp/wp7413493.jpg",
                                    large_text="Playing TFT",
                                    details="Teamfight Tactics",
                                    state=f"In Game · lvl: {get_level()}",
                                    small_image=LEAGUE_OF_LEGENDS_LOGO,
                                    small_text=SMALL_TEXT,
                                    start=int(time.time())
                                    - get_current_ingame_time(default_time=start_time),
                                )
                            except RuntimeError:
                                print(
                                    f"{Color.red}Discord seems to be closed, will attempt to reconnect!{Color.reset}"
                                )
                                discord_reconnect_attempt(rpc=rpc)
                            time.sleep(10)
                    elif gamemode == "Arena":
                        # ARENA RPC
                        skin_asset: str = get_skin_asset(
                            champion_name=champ_name,
                            skin_id=skin_id,
                        )
                        print(
                            f"{Color.green}Successfully gathered all data. Updating your Presence now!{Color.reset}"
                        )
                        while player_state() == "InGame":
                            check_focus_and_exit()
                            large_text = (
                                f"{skin_name} ({chroma_name})"
                                if chroma_name
                                else (
                                    skin_name
                                    if skin_name
                                    else CHAMPION_NAME_CONVERT_MAP.get(
                                        champ_name, champ_name
                                    )
                                )
                            )
                            try:
                                rpc.update(  # type:ignore
                                    large_image=skin_asset,
                                    large_text=large_text,
                                    details=gamemode,
                                    state=f"In Game {f'· {get_kda()} · lvl: {get_level()} · gold: {get_gold()}' if not cli_args.no_stats else ''}",
                                    small_image=LEAGUE_OF_LEGENDS_LOGO,
                                    small_text=SMALL_TEXT,
                                    start=int(time.time())
                                    - get_current_ingame_time(default_time=start_time),
                                )
                            except RuntimeError:
                                print(
                                    f"{Color.red}Discord seems to be closed, will attempt to reconnect!{Color.reset}"
                                )
                                discord_reconnect_attempt(rpc=rpc)
                            time.sleep(10)

                    elif gamemode == "Swarm - PVE":
                        # Swarm PVE RPC
                        skin_asset: str = get_skin_asset(
                            champion_name=champ_name,
                            skin_id=skin_id,
                        )
                        print(
                            f"{Color.green}Successfully gathered all data. Updating your Presence now!{Color.reset}"
                        )
                        while player_state() == "InGame":
                            check_focus_and_exit()
                            large_text = (
                                f"{skin_name} ({chroma_name})"
                                if chroma_name
                                else (
                                    skin_name
                                    if skin_name
                                    else CHAMPION_NAME_CONVERT_MAP.get(
                                        champ_name, champ_name
                                    )
                                )
                            )
                            try:
                                rpc.update(  # type:ignore
                                    large_image=skin_asset,
                                    large_text=large_text,
                                    details=gamemode,
                                    state=f"In Game {f'· {get_creepscore()} · lvl: {get_level()} · gold: {get_gold()}' if not cli_args.no_stats else ''}",
                                    small_image=LEAGUE_OF_LEGENDS_LOGO,
                                    small_text=SMALL_TEXT,
                                    start=int(time.time())
                                    - get_current_ingame_time(default_time=start_time),
                                )
                            except RuntimeError:
                                print(
                                    f"{Color.red}Discord seems to be closed, will attempt to reconnect!{Color.reset}"
                                )
                                discord_reconnect_attempt(rpc=rpc)
                            time.sleep(10)
                    else:
                        # LEAGUE RPC
                        skin_asset = get_skin_asset(
                            champion_name=champ_name,
                            skin_id=skin_id,
                        )
                        print(
                            f"{Color.green}Successfully gathered all data. Updating your Presence now!{Color.reset}"
                        )
                        while player_state() == "InGame":
                            check_focus_and_exit()
                            if not champ_name or not gamemode:
                                break
                            large_text = (
                                f"{skin_name} ({chroma_name})"
                                if chroma_name
                                else (
                                    skin_name
                                    if skin_name
                                    else CHAMPION_NAME_CONVERT_MAP.get(
                                        champ_name, champ_name
                                    )
                                )
                            )
                            try:
                                rpc.update(  # type:ignore
                                    large_image=skin_asset,
                                    large_text=large_text,
                                    details=gamemode,
                                    state=f"In Game {f'· {get_kda()} · {get_creepscore()}' if not cli_args.no_stats else ''}",
                                    small_image=LEAGUE_OF_LEGENDS_LOGO,
                                    small_text=SMALL_TEXT,
                                    start=int(time.time())
                                    - get_current_ingame_time(default_time=start_time),
                                )
                            except RuntimeError:
                                print(
                                    f"{Color.red}Discord seems to be closed, will attempt to reconnect!{Color.reset}"
                                )
                                discord_reconnect_attempt(rpc=rpc)
                            time.sleep(10)

                case "InLobby":
                    # Handled by lcu_process thread
                    # It will subscribe to websockets and update discord on events.

                    time.sleep(10)

                case _:
                    print(
                        f"{Color.red}LeagueOfLegends.exe was terminated. rpc shutting down..{Color.reset}."
                    )
                    rpc.close()
                    sys.exit()
        except pypresence.exceptions.PipeClosed:
            # If the program crashes because pypresence failed to connect to a pipe. (Typically if Discord is closed.)
            # The script will automatically try to reconnect..
            # if it fails it will keep going until you either reconnect or after a long enough period of time has passed
            print(
                f"{Color.red}Discord seems to be closed, will attempt to reconnect!{Color.reset}"
            )
            discord_reconnect_attempt(rpc=rpc, amount_of_tries=12, amount_of_waiting=5)


if __name__ == "__main__":
    # Patch for asyncio - read more here: https://pypi.org/project/nest-asyncio/
    nest_asyncio.apply()  # type: ignore

    parser = argparse.ArgumentParser(description="Script with Discord RPC.")
    parser.add_argument(
        "--client-id",
        type=str,
        default=DEFAULT_CLIENT_ID,
        help=f"Client ID for Discord RPC. Default is {DEFAULT_CLIENT_ID}. which will show 'League of Legends' on Discord",
    )
    parser.add_argument(
        "--no-stats",
        action="store_true",
        help="use '--no-stats' to Opt out of showing in-game stats (KDA, minions) in Discord RPC",
    )
    parser.add_argument(
        "--show-emojis",
        "--emojis",
        action="store_true",
        help="use '--show-emojis' to show green/red circle emoji, depending on your Online status in league.",
    )
    parser.add_argument(
        "--no-rank",
        action="store_true",
        help="use '--no-rank' to hide your SoloQ/Flex/Tft/Arena Rank in Discord RPC",
    )
    parser.add_argument(
        "--add-process",
        nargs="+",
        default=[],
        help="Add custom Discord process names to the search list.",
    )
    parser.add_argument(
        "--wait-for-league",
        type=int,
        default=1,
        help="Time in seconds to wait for the League client to start. -1 for infinite waiting, Good when used as a starting script for league.",
    )
    parser.add_argument(
        "--wait-for-discord",
        type=int,
        default=1,
        help="Time in seconds to wait for the Discord client to start. -1 for infinite waiting, Good when you want to start this script before you've had time to start Discord.",
    )
    parser.add_argument(
        "--launch-league",
        type=str,
        default=DEFAULT_LEAGUE_CLIENT_EXE_PATH,
        help=f"Path to the League of Legends client executable. Default path is: {DEFAULT_LEAGUE_CLIENT_EXE_PATH}",
    )

    args: argparse.Namespace = parser.parse_args()

    # Prints the League RPC logo
    print(Color().logo)

    if args.no_stats:
        print(
            f"{Color.green}Argument {Color.blue}--no-stats{Color.green} detected.. Will {Color.red}not {Color.green}show InGame stats{Color.reset}"
        )
    if args.no_rank:
        print(
            f"{Color.green}Argument {Color.blue}--no-rank{Color.green} detected.. Will hide your league rank.{Color.reset}"
        )
    if args.show_emojis:
        print(
            f"{Color.green}Argument {Color.blue}--show-emojis, --emojis{Color.green} detected.. Will show emojis. such as league status indicators on Discord.{Color.reset}"
        )
    if args.add_process:
        print(
            f"{Color.green}Argument {Color.blue}--add-process{Color.green} detected.. Will add {Color.blue}{args.add_process}{Color.green} to the list of Discord processes to look for.{Color.reset}"
        )

    if args.client_id != DEFAULT_CLIENT_ID:
        print(
            f"{Color.green}Argument {Color.blue}--client-id{Color.green} detected.. Will try to connect by using {Color.blue}({args.client_id}){Color.reset}"
        )
    if args.wait_for_league and args.wait_for_league > 0:
        print(
            f"{Color.green}Argument {Color.blue}--wait-for-league{Color.green} detected.. {Color.blue}will wait for League to start before continuing{Color.reset}"
        )
    if args.wait_for_discord and args.wait_for_discord > 0:
        print(
            f"{Color.green}Argument {Color.blue}--wait-for-discord{Color.green} detected.. {Color.blue}will wait for Discord to start before continuing{Color.reset}"
        )
    

    if args.launch_league:
        if args.launch_league == DEFAULT_LEAGUE_CLIENT_EXE_PATH:
            print(
                f"{Color.green}Attempting to launch the League client at the default location{Color.reset} {Color.blue}{args.launch_league}{Color.reset}\n"
                f"{Color.green}If league is already running, it will not launch a new instance.{Color.reset}\n"
                f"{Color.orange}If the League client does not launch, please specify the path manually using: --launch-league <path>{Color.reset}\n"
            )
        else:
            print(
                f"{Color.green}Detected the {Color.blue}--launch-league{Color.green} argument with a custom path. Attempting to launch the League client, from: {Color.blue}{args.launch_league}{Color.reset}\n"
                f"{Color.orange}If league is already running, it will not launch a new instance.{Color.reset}\n"
            )

    main(cli_args=args)


--- .\presets\league-of-legends\league_rpc\champion.py ---

from http import HTTPStatus
from typing import Any, Optional

import requests
import urllib3
from league_rpc.disable_native_rpc.disable import find_game_locale
from league_rpc.kda import get_gold, get_level
from league_rpc.latest_version import get_latest_version
from league_rpc.username import get_riot_id
from league_rpc.utils.color import Color
from league_rpc.utils.const import (
    ALL_GAME_DATA_URL,
    BASE_SKIN_URL,
    CHAMPION_NAME_CONVERT_MAP,
    DDRAGON_CHAMPION_DATA,
    GAME_MODE_CONVERT_MAP,
    MERAKIANALYTICS_CHAMPION_DATA,
)
from league_rpc.utils.polling import wait_until_exists

urllib3.disable_warnings()


def get_specific_champion_data(name: str, locale: str) -> dict[str, Any]:
    """
    Get the specific champion data for the champion name.
    """
    response: requests.Response = requests.get(
        url=DDRAGON_CHAMPION_DATA.format_map(
            {
                "version": get_latest_version(),
                "name": name,
                "locale": locale,
            }
        ),
        timeout=15,
    )
    return response.json()


def get_specific_chroma_data(name: str, locale: str) -> dict[str, Any]:
    """
    Get the specific chroma champion data for the champion name.
    """
    url = MERAKIANALYTICS_CHAMPION_DATA.format_map(
        {
            "locale": locale.replace("_", "-"),
        }
    )
    response: requests.Response = requests.get(
        url=url,
        timeout=15,
    )
    return response.json()[name]


def gather_ingame_information() -> tuple[str, str, str, int, str, int, int]:
    """
    Get the current playing champion name.
    """
    your_summoner_name: str = get_riot_id()

    champion_name: str | None = None
    skin_id: int | None = None
    skin_name: str | None = None
    chroma_name: str | None = None
    game_mode: str | None = (
        None  # Set if the game mode was never found.. Maybe you are playing something new?
    )
    level: int | None = None
    gold: int | None = None

    if response := wait_until_exists(
        url=ALL_GAME_DATA_URL,
        custom_message="Did not find game data.. Will try again in 5 seconds",
    ):
        parsed_data = response.json()
        game_mode = GAME_MODE_CONVERT_MAP.get(
            parsed_data["gameData"]["gameMode"],
            parsed_data["gameData"]["gameMode"],
        )

        if game_mode == "TFT":
            # If the currentGame is TFT.. gather the relevant information
            level = get_level()
        else:
            # If the gamemode is LEAGUE gather the relevant information.
            champion_name, skin_id, skin_name, chroma_name = gather_league_data(
                parsed_data=parsed_data, summoners_name=your_summoner_name
            )
            if game_mode in ("Arena", "Swarm - PVE"):
                level, gold = get_level(), get_gold()
            print("-" * 50)
            if champion_name:
                print(
                    f"{Color.yellow}Champion name found {Color.green}({CHAMPION_NAME_CONVERT_MAP.get(champion_name, champion_name)}),{Color.yellow} continuing..{Color.reset}"
                )
            if skin_name:
                print(
                    f"{Color.yellow}Skin detected: {Color.green}{skin_name},{Color.yellow} continuing..{Color.reset}"
                )
            if chroma_name:
                print(
                    f"{Color.yellow}Chroma detected: {Color.green}{chroma_name},{Color.yellow} continuing..{Color.reset}"
                )
            if game_mode:
                print(
                    f"{Color.yellow}Game mode detected: {Color.green}{game_mode},{Color.yellow} continuing..{Color.reset}"
                )
            print("-" * 50)

    # Returns default values if information was not found.
    return (
        (champion_name or ""),
        (skin_name or ""),
        (chroma_name or ""),
        (skin_id or 0),
        (game_mode or ""),
        (level or 0),
        (gold or 0),
    )


def gather_league_data(
    parsed_data: dict[str, Any],
    summoners_name: str,
) -> tuple[Optional[str], int, Optional[str], Optional[str]]:
    """
    If the gamemode is LEAGUE, gather the relevant information and return it to RPC.
    """
    champion_name: Optional[str] = None
    skin_id: int = 0
    base_skin_id: int = 0
    skin_name: Optional[str] = None
    chroma_name: Optional[str] = None
    locale = find_game_locale(
        league_processes=["LeagueClient.exe", "LeagueClientUx.exe"]
    )

    for player in parsed_data["allPlayers"]:
        if player["riotId"] == summoners_name:
            raw_champion_name: str = player["rawChampionName"].split("_")[-1]
            champion_data: dict[str, Any] = get_specific_champion_data(
                name=raw_champion_name,
                locale=locale,
            )
            champion_name = champion_data["data"][raw_champion_name]["id"]
            skin_name = player.get("skinName", None)
            skin_id = player.get("skinID", None)

            if skin_name:
                base_skin_id = [
                    x["num"]
                    for x in champion_data["data"][raw_champion_name]["skins"]
                    if x["name"] == skin_name
                ][0]
            if skin_id != base_skin_id:
                # Chroma detected: Get the name of the chroma:
                chroma_data = get_specific_chroma_data(
                    name=raw_champion_name,
                    locale="en-US",
                )
                _skin_data: dict[str, Any] = [
                    x
                    for x in chroma_data["skins"]
                    if str(x["id"]).endswith(str(base_skin_id))
                ][0]
                chroma_name = [
                    x["name"]
                    for x in _skin_data["chromas"]
                    if str(x["id"]).endswith(str(skin_id))
                ][0]

            break
        continue
    return champion_name, base_skin_id, skin_name, chroma_name


def get_skin_asset(
    champion_name: str,
    skin_id: int,
) -> str:
    """
    Returns the URL for the skin/default skin of the champion.
    If a chroma has been selected, it will return the base skin for that chroma.
        Since RIOT does not have individual images for each chroma.
    """

    while skin_id:
        url: str = f"{BASE_SKIN_URL}{champion_name}_{skin_id}.jpg"
        if not check_url(url=url):
            skin_id -= 1
            continue

        return url
    url = f"{BASE_SKIN_URL}{champion_name}_0.jpg"
    return url


def check_url(url: str) -> bool:
    """
    Sends a HEAD request to the URL and,
    returns a boolean value depending on if the request,
    was successful (200 OK) or not.
    """
    return requests.head(url=url, timeout=15).status_code == HTTPStatus.OK


--- .\presets\league-of-legends\league_rpc\gametime.py ---

import urllib3

from league_rpc.utils.polling import wait_until_exists

urllib3.disable_warnings()


def get_current_ingame_time(default_time: int) -> int:
    """
    Gets the current time of the game.
    """
    url = "https://127.0.0.1:2999/liveclientdata/gamestats"
    if response := wait_until_exists(
        url=url,
        custom_message="""
        Was unable to find the game time.
        Fallback (the time from which you executed this script) is now set as the 'elapsed time' of the game
        "Contact @haze.dev on discord, or submit a ticket on Github.
        """,
    ):
        return int(response.json()["gameTime"])
    return default_time


--- .\presets\league-of-legends\league_rpc\kda.py ---

import urllib3
from requests import Response

from league_rpc.username import get_riot_id
from league_rpc.utils.const import ACTIVE_PLAYER_URL, PLAYER_KDA_SCORES_URL
from league_rpc.utils.polling import wait_until_exists

urllib3.disable_warnings()


def get_kda() -> str:
    """
    Get the current KDA of your game.
    """
    response = get_current_user_stats()
    if isinstance(response, Response):
        parsed_data = response.json()
        kills = str(parsed_data["kills"])
        deaths = str(parsed_data["deaths"])
        assists = str(parsed_data["assists"])

        return f"{kills}/{deaths}/{assists}"
    return ""


def get_level() -> int:
    """
    Get the current Level of your game.
    """
    response = get_current_active_player_stats()
    if isinstance(response, Response):
        parsed_data = response.json()
        level = int(parsed_data["level"])

        return level
    return 0


def get_gold() -> int:
    """
    Get the current gold of your game.
    """
    response = get_current_active_player_stats()
    if isinstance(response, Response):
        parsed_data = response.json()
        gold = int(parsed_data["currentGold"])

        return gold
    return 0


def get_creepscore() -> str:
    """
    Get the current creepScore of your live game
    creepScore is updated every 10cs by Riot.
    """
    response = get_current_user_stats()
    if isinstance(response, Response):
        parsed_data = response.json()
        creep_score = str(parsed_data["creepScore"])
        return f"{creep_score}cs"

    return ""


def get_current_user_stats() -> Response | None:
    """
    Request data from playerscores?riotId and return the response.
    """
    your_riot_id = get_riot_id()
    if your_riot_id:
        # If the summoner name is not found, we don't want the KDA.
        player_score_url = PLAYER_KDA_SCORES_URL.format_map({"riotId": your_riot_id})
        if response := wait_until_exists(url=player_score_url):
            return response
    return None


def get_current_active_player_stats() -> Response | None:
    """
    Request data from liveclientdata/activeplayer and return the response.
    """
    if response := wait_until_exists(url=ACTIVE_PLAYER_URL):
        return response
    return None


--- .\presets\league-of-legends\league_rpc\latest_version.py ---

import requests

from league_rpc.utils.const import DDRAGON_API_VERSIONS


def get_latest_version() -> str:
    response = requests.get(url=DDRAGON_API_VERSIONS, timeout=15)

    data = response.json()
    latest_version = data[0]
    return latest_version


--- .\presets\league-of-legends\league_rpc\reconnect.py ---

"""
Holds functions to try to reconnect to discord whenever the pipe closes or discord suddenly crashes.
"""

import sys
import time

import pypresence

from league_rpc.utils.color import Color


def discord_reconnect_attempt(
    rpc: pypresence.Presence,
    amount_of_tries: int = 12,
    amount_of_waiting: int = 5,
):
    """
    Attempts to connect to discord, over a period of time. If it still fails, it will exit the program.
    """
    for i in range(amount_of_tries):
        try:
            time.sleep(amount_of_waiting)
            print(
                f"{Color.yellow}({i + 1}/{amount_of_tries}). Attempting to reconnect..{Color.reset}"
            )
            rpc.connect()
            print(
                f"{Color.green}Successfully reconnected.. Proceeding as normal.{Color.reset}"
            )
            break

        except (
            pypresence.exceptions.DiscordNotFound,
            pypresence.exceptions.DiscordError,
            pypresence.exceptions.InvalidPipe,
            pypresence.exceptions.PipeClosed,
            ConnectionError,
        ):
            pass
    else:
        print(
            f"{Color.red}Was unable to reconnect to Discord. after trying for {amount_of_tries * amount_of_waiting} seconds.{Color.reset}"
        )
        sys.exit()


--- .\presets\league-of-legends\league_rpc\username.py ---

from typing import Any

import urllib3

from league_rpc.utils.const import ACTIVE_PLAYER_URL
from league_rpc.utils.polling import wait_until_exists

urllib3.disable_warnings()


def get_riot_id(without_discriminator: bool = False) -> str:
    """
    Gets the current summoner name.

    if without_discriminator is True, the function will not return a summoners name with #EUW / #EUNE etc
        Defaults to include it.

    """
    if response := wait_until_exists(
        url=ACTIVE_PLAYER_URL,
        custom_message="""
            Summoner name could not be found.
            Contact @haze.dev on discord, or submit a ticket on Github.
            """,
    ):
        _response: dict[str, Any] = response.json()
        name_without_discriminator = _response["riotIdGameName"]
        riot_id = _response["riotId"]

        return name_without_discriminator if without_discriminator else riot_id

    return ""


--- .\presets\league-of-legends\league_rpc\__init__.py ---



--- .\presets\league-of-legends\league_rpc\__version__.py ---

"""Set version number of package."""

__version__ = "v2.3.0"
import requests

RELEASES_PAGE = "https://github.com/Its-Haze/league-rpc/releases"


def get_version_from_github() -> str | None:
    """
    Get the latest version of the software from the GitHub repository.

    Returns:
        str: The latest version of the software.
    """
    response: requests.Response = requests.get(
        url="https://api.github.com/repos/its-haze/league-rpc/releases/latest",
        timeout=15,
    )
    if response.status_code != 200:
        # Probably due to rate limit.. should be handled better.
        return None

    return response.json()["tag_name"]


def check_latest_version() -> bool | None:
    """
    Check if the current version of the software is the latest version available.

    Returns:
        bool: True if the current version is not the latest version, False otherwise.
    """
    latest_version: str | None = get_version_from_github()
    if latest_version is None:
        return None
    return latest_version > __version__


--- .\presets\league-of-legends\league_rpc\disable_native_rpc\disable.py ---

import json
import os
from typing import Any, Optional

import psutil

from league_rpc.utils.color import Color

LEAGUE_NATIVE_RPC_PLUGIN = "rcp-be-lol-discord-rp"


def check_plugin_status(
    file_path: str,
    plugin_name: str = LEAGUE_NATIVE_RPC_PLUGIN,
) -> None:
    """Check if a specific plugin is still in the manifest file and inform the user."""
    data: dict[str, Any] | None = load_json_file(file_path=file_path)
    if data is None:
        return

    plugin_found: bool = any(
        plugin["name"] == plugin_name for plugin in data.get("plugins", [])
    )
    if plugin_found:
        print(
            f"{Color.yellow}The Native League Presence is still active. Please start this application before launching League of legends to fully disable it.{Color.reset}"
        )


def load_json_file(file_path: str) -> Optional[dict[str, Any]]:
    """Load a JSON file from the provided path."""
    try:
        with open(file=file_path, mode="r+", encoding="utf-8") as file:
            return json.load(fp=file)
    except FileNotFoundError:
        print(f"{Color.red}No JSON file at {file_path}{Color.reset}")
        return None


def save_json_file(file_path: str, data: dict[str, Any]) -> None:
    """Save a dictionary to a JSON file."""
    with open(file=file_path, mode="w+", encoding="utf-8") as file:
        json.dump(obj=data, fp=file, indent=4)
        file.truncate()


def modify_json_data(
    data: dict[str, Any],
    plugin_name: str = LEAGUE_NATIVE_RPC_PLUGIN,
) -> bool:
    """Remove the specified plugin from the data."""
    modified = False
    for plugin in data.get("plugins", []):
        if plugin["name"] == plugin_name:
            data["plugins"].remove(plugin)
            modified = True
    return modified


def check_and_modify_json(file_path: str) -> None:
    """Remove a specific plugin from the League manifest file."""
    data: dict[str, Any] | None = load_json_file(file_path=file_path)
    if data is None:
        return

    if modify_json_data(data=data):
        print(
            f"\n{Color.orange}Native league rpc found. Will disable it now.{Color.reset}"
        )
        save_json_file(file_path=file_path, data=data)
        print(
            f"{Color.green}Successfully disabled League Native Rich Presence{Color.reset}\n"
        )

    # For debugging purposes only.
    # else:
    #     print(f"{Colors.blue}No modifications necessary.{Colors.reset}")


def find_game_locale(league_processes: list[str]) -> str:
    """Find the locale, en_US, or something else of the current league process."""

    for proc in psutil.process_iter(attrs=["cmdline", "name"]):
        try:
            if proc.info["name"] in league_processes:
                locale_str: str = [
                    x for x in proc.info["cmdline"] if x.startswith("--locale=")
                ][0]
                locale: str = locale_str.split("=")[1]
                return locale
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue

    print(f"{Color.orange}No locale found, defaulting to en_US{Color.reset}")
    return "en_US"


def find_game_path() -> Optional[str]:
    """Find the path to the plugin-manifest.json file for League of Legends."""
    target_process = "RiotClientServices.exe"
    riot_path_identifier = "Riot Games"

    for proc in psutil.process_iter(attrs=["pid", "name", "exe"]):
        try:
            if (
                proc.info["name"] == target_process
                and riot_path_identifier in proc.info["exe"]
            ):
                base_path: Any = (
                    proc.info["exe"].split(riot_path_identifier)[0]
                    + riot_path_identifier
                )
                return os.path.join(
                    base_path, "League of Legends", "Plugins", "plugin-manifest.json"
                )
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    return None


--- .\presets\league-of-legends\league_rpc\lcu_api\base_data.py ---

from typing import Any

from aiohttp import ClientResponse
from lcu_driver.connection import Connection

from league_rpc.models.client_data import ArenaStats, ClientData, RankedStats, TFTStats
from league_rpc.models.lcu.current_chat_status import LolChatUser
from league_rpc.models.lcu.current_queue import LolGameQueuesQueue
from league_rpc.models.lcu.current_summoner import Summoner
from league_rpc.models.lcu.gameflow_phase import (
    GameFlowPhase,
    LolGameflowLobbyStatus,
    LolGameflowPlayerStatus,
)
from league_rpc.models.module_data import ModuleData


# Base Data
# Gather base data from the LCU API on startup
async def gather_base_data(connection: Connection, module_data: ModuleData) -> None:
    data: ClientData = module_data.client_data

    # Epoch time from which league client was started.
    await gather_telemetry_data(connection=connection, data=data)

    await gather_summoner_data(connection=connection, data=data)

    # get Online/Away status
    await gather_chat_status_data(connection=connection, data=data)

    await gather_ranked_data(connection=connection, data=data)

    await gather_gameflow_data(connection=connection, data=data)

    if data.gameflow_phase == GameFlowPhase.IN_PROGRESS:
        # In Game
        return

    if data.gameflow_phase == GameFlowPhase.NONE:
        # In Client
        return

    await gather_lobby_data(connection=connection, data=data)

    if data.queue_id == -1:
        # custom game / practice tool / tutorial lobby
        data.gamemode = "PRACTICETOOL"
        data.map_id = 11
        if data.is_practice:
            data.queue = "Practice Tool"
            data.max_players = 1
        else:
            data.queue = "Custom Game"

        return

    await gather_queue_data(connection=connection, data=data)


async def gather_queue_data(connection: Connection, data: ClientData) -> None:
    lobby_queue_info_raw: ClientResponse = await connection.request(
        method="GET", endpoint="/lol-game-queues/v1/queues/" + str(data.queue_id)
    )
    lobby_queue_info: Any = await lobby_queue_info_raw.json()
    data.queue = lobby_queue_info[LolGameQueuesQueue.NAME]
    data.queue_type = lobby_queue_info[LolGameQueuesQueue.TYPE]
    data.max_players = int(
        lobby_queue_info[LolGameQueuesQueue.MAXIMUM_PARTICIPANT_LIST_SIZE]
    )
    data.map_id = lobby_queue_info[LolGameQueuesQueue.MAP_ID]
    data.gamemode = lobby_queue_info[LolGameQueuesQueue.GAME_MODE]
    data.queue_is_ranked = lobby_queue_info[LolGameQueuesQueue.IS_RANKED]


async def gather_lobby_data(connection: Connection, data: ClientData) -> None:
    lobby_raw_data: ClientResponse = await connection.request(
        method="GET", endpoint="/lol-gameflow/v1/gameflow-metadata/player-status"
    )
    lobby_data: dict[str, Any] = await lobby_raw_data.json()

    data.queue_id = lobby_data[LolGameflowPlayerStatus.CURRENT_LOBBY_STATUS][
        LolGameflowLobbyStatus.QUEUE_ID
    ]
    data.lobby_id = lobby_data[LolGameflowPlayerStatus.CURRENT_LOBBY_STATUS][
        LolGameflowLobbyStatus.LOBBY_ID
    ]
    data.players = len(
        lobby_data[LolGameflowPlayerStatus.CURRENT_LOBBY_STATUS][
            LolGameflowLobbyStatus.MEMBER_SUMMONER_IDS
        ]
    )
    data.is_practice = lobby_data[LolGameflowPlayerStatus.CURRENT_LOBBY_STATUS][
        LolGameflowLobbyStatus.IS_PRACTICE_TOOL
    ]
    data.is_custom = lobby_data[LolGameflowPlayerStatus.CURRENT_LOBBY_STATUS][
        LolGameflowLobbyStatus.IS_CUSTOM
    ]


async def gather_gameflow_data(connection: Connection, data: ClientData) -> None:
    game_flow_data_raw: ClientResponse = await connection.request(
        method="GET", endpoint="/lol-gameflow/v1/gameflow-phase"
    )
    game_flow_data: str = await game_flow_data_raw.json()
    data.gameflow_phase = game_flow_data


async def gather_ranked_data(connection: Connection, data: ClientData) -> None:
    ranked_data_raw: ClientResponse = await connection.request(
        method="GET", endpoint="/lol-ranked/v1/current-ranked-stats/"
    )
    ranked_data: dict[str, Any] = await ranked_data_raw.json()

    data.summoner_rank = RankedStats.from_map(
        obj_map=ranked_data,
        ranked_type="RANKED_SOLO_5x5",
    )
    data.summoner_rank_flex = RankedStats.from_map(
        obj_map=ranked_data,
        ranked_type="RANKED_FLEX_SR",
    )

    data.arena_rank = ArenaStats.from_map(obj_map=ranked_data)
    data.tft_rank = TFTStats.from_map(obj_map=ranked_data)


async def gather_chat_status_data(connection: Connection, data: ClientData) -> None:
    chat_data_raw: ClientResponse = await connection.request(
        method="GET", endpoint="/lol-chat/v1/me"
    )
    chat_data: dict[str, Any] = await chat_data_raw.json()

    match chat_data[LolChatUser.AVAILABILITY]:
        case LolChatUser.CHAT:
            data.availability = LolChatUser.ONLINE.capitalize()
        case LolChatUser.AWAY:
            data.availability = LolChatUser.AWAY.capitalize()
        case _:
            ...


async def gather_summoner_data(connection: Connection, data: ClientData) -> None:
    summoner_data_raw: ClientResponse = await connection.request(
        method="GET", endpoint="/lol-summoner/v1/current-summoner"
    )
    summoner_data = await summoner_data_raw.json()

    data.summoner_level = summoner_data.get(Summoner.SUMMONER_LEVEL, 0)
    data.summoner_icon = summoner_data[Summoner.PROFILE_ICON_ID]


async def gather_telemetry_data(connection: Connection, data: ClientData) -> None:
    application_start_time_raw: ClientResponse = await connection.request(
        method="GET", endpoint="/telemetry/v1/application-start-time"
    )
    application_start_time: int = await application_start_time_raw.json()
    data.application_start_time = application_start_time


--- .\presets\league-of-legends\league_rpc\lcu_api\lcu_connector.py ---

import time
from argparse import Namespace
from typing import Any, Optional

from aiohttp import ClientResponse
from lcu_driver.connection import Connection  # type:ignore
from lcu_driver.events.responses import WebsocketEventResponse  # type:ignore
from pypresence import Presence  # type:ignore

from league_rpc.disable_native_rpc.disable import check_plugin_status, find_game_path
from league_rpc.lcu_api.base_data import gather_base_data
from league_rpc.models.client_data import ArenaStats, ClientData, RankedStats, TFTStats
from league_rpc.models.lcu.current_chat_status import LolChatUser
from league_rpc.models.lcu.current_lobby import (
    LolLobbyLobbyDto,
    LolLobbyLobbyGameConfigDto,
)
from league_rpc.models.lcu.current_queue import LolGameQueuesQueue
from league_rpc.models.lcu.current_summoner import Summoner
from league_rpc.models.module_data import ModuleData
from league_rpc.models.rpc_updater import RPCUpdater
from league_rpc.utils.color import Color

module_data = ModuleData()
rpc_updater = RPCUpdater()

## WS Events ##


@module_data.connector.ready  # type:ignore
async def connect(connection: Connection) -> None:
    print(f"{Color.green}Successfully connected to the League Client API.{Color.reset}")
    time.sleep(2)  # Give the client some time to load

    print(f"\n{Color.orange}Gathering base data.{Color.reset}")
    time.sleep(2)
    await gather_base_data(connection=connection, module_data=module_data)

    print(f"{Color.green}Successfully gathered base data.{Color.reset}")

    print(f"\n{Color.orange}Updating Discord rpc with base data{Color.reset}")
    rpc_updater.delay_update(module_data=module_data)
    print(f"{Color.green}Discord RPC successfully updated{Color.reset}")

    print(f"\n{Color.cyan}LeagueRPC is ready{Color.reset}")

    if game_path := find_game_path():
        check_plugin_status(file_path=game_path)


@module_data.connector.close  # type:ignore
async def disconnect(_: Connection) -> None:
    print(f"{Color.red}Disconnected from the League Client API.{Color.reset}")


@module_data.connector.ws.register(  # type:ignore
    uri="/lol-summoner/v1/current-summoner", event_types=("UPDATE",)
)
async def summoner_updated(_: Connection, event: WebsocketEventResponse) -> None:
    data: ClientData = module_data.client_data
    event_data: dict[str, Any] = event.data  # type:ignore

    data.summoner_level = event_data.get(Summoner.SUMMONER_LEVEL, 0)
    data.summoner_icon = event_data.get(Summoner.PROFILE_ICON_ID, 0)

    rpc_updater.delay_update(module_data=module_data)


@module_data.connector.ws.register(  # type:ignore
    uri="/lol-chat/v1/me", event_types=("UPDATE",)
)
async def chat_updated(_: Connection, event: WebsocketEventResponse) -> None:
    data: ClientData = module_data.client_data
    event_data: dict[str, Any] = event.data  # type:ignore

    match event_data[LolChatUser.AVAILABILITY]:
        case LolChatUser.CHAT:
            data.availability = LolChatUser.ONLINE.capitalize()

        case LolChatUser.AWAY:
            data.availability = LolChatUser.AWAY.capitalize()
        case _:
            ...
    rpc_updater.delay_update(module_data=module_data)


@module_data.connector.ws.register(  # type:ignore
    "/lol-gameflow/v1/gameflow-phase", event_types=("UPDATE",)
)
async def gameflow_phase_updated(_: Connection, event: WebsocketEventResponse) -> None:
    data: ClientData = module_data.client_data
    event_data: Any = event.data  # type:ignore

    data.gameflow_phase = event_data  # returns plain string of the phase
    rpc_updater.delay_update(module_data=module_data)


# could be used for lobby instead: /lol-gameflow/v1/gameflow-metadata/player-status
@module_data.connector.ws.register(  # type:ignore
    uri="/lol-lobby/v2/lobby", event_types=("UPDATE", "CREATE", "DELETE")
)
async def in_lobby(connection: Connection, event: WebsocketEventResponse) -> None:
    data: ClientData = module_data.client_data
    event_data: Optional[dict[str, Any]] = event.data  # type:ignore

    if event_data is None:
        # Make an early return if data is not present in the event.
        return

    data.queue_id = int(
        event_data[LolLobbyLobbyDto.GAME_CONFIG][
            LolLobbyLobbyGameConfigDto.QUEUE_ID
        ]  # type:ignore
    )
    data.lobby_id = event_data[LolLobbyLobbyDto.PARTY_ID]
    data.players = len(event_data[LolLobbyLobbyDto.MEMBERS])  # type:ignore
    data.max_players = int(
        event_data[LolLobbyLobbyDto.GAME_CONFIG][  # type:ignore
            LolLobbyLobbyGameConfigDto.MAX_LOBBY_SIZE
        ]
    )
    data.map_id = event_data[LolLobbyLobbyDto.GAME_CONFIG][
        LolLobbyLobbyGameConfigDto.MAP_ID
    ]
    data.gamemode = event_data[LolLobbyLobbyDto.GAME_CONFIG][
        LolLobbyLobbyGameConfigDto.GAME_MODE
    ]
    data.is_custom = event_data[LolLobbyLobbyDto.GAME_CONFIG][
        LolLobbyLobbyGameConfigDto.IS_CUSTOM
    ]
    if (
        event_data[LolLobbyLobbyDto.GAME_CONFIG][LolLobbyLobbyGameConfigDto.GAME_MODE]
        == "PRACTICETOOL"
    ):
        data.is_practice = True
        data.max_players = 1
    else:
        data.is_practice = False

    if data.queue_id == -1:
        # custom game / practice tool / tutorial lobby
        if data.is_practice:
            data.queue = "Practice Tool"
        else:
            data.queue = "Custom Game"
        rpc_updater.delay_update(module_data)
        return

    lobby_queue_info_raw: ClientResponse = await connection.request(
        method="GET",
        endpoint="/lol-game-queues/v1/queues/{id}".format_map({"id": data.queue_id}),
    )
    lobby_queue_info: dict[str, Any] = await lobby_queue_info_raw.json()

    data.queue = lobby_queue_info[LolGameQueuesQueue.NAME]
    data.queue_type = lobby_queue_info[LolGameQueuesQueue.TYPE]
    data.queue_is_ranked = lobby_queue_info[LolGameQueuesQueue.IS_RANKED]

    rpc_updater.delay_update(module_data=module_data)


# ranked stats
@module_data.connector.ws.register(  # type:ignore
    uri="/lol-ranked/v1/current-ranked-stats", event_types=("UPDATE",)
)
async def ranked(_: Connection, event: WebsocketEventResponse) -> None:
    data: ClientData = module_data.client_data
    event_data: dict[str, Any] = event.data  # type:ignore

    data.summoner_rank = RankedStats.from_map(
        obj_map=event_data,
        ranked_type="RANKED_SOLO_5x5",
    )
    data.summoner_rank_flex = RankedStats.from_map(
        obj_map=event_data,
        ranked_type="RANKED_FLEX_SR",
    )

    data.arena_rank = ArenaStats.from_map(obj_map=event_data)
    data.tft_rank = TFTStats.from_map(obj_map=event_data)

    rpc_updater.delay_update(module_data)


###### Debug ######
# This will catch all events and print them to the console.

# @module_data.connector.ws.register(  # type:ignore
#    "/", event_types=("UPDATE", "CREATE", "DELETE")
# )
# async def debug(connection: Connection, event: WebsocketEventResponse) -> None:
#    print(f"DEBUG - {event.type}: {event.uri}")


def start_connector(rpc_from_main: Presence, cli_args: Namespace) -> None:
    module_data.rpc = rpc_from_main
    module_data.cli_args = cli_args
    module_data.connector.start()


--- .\presets\league-of-legends\league_rpc\lcu_api\__init__.py ---



--- .\presets\league-of-legends\league_rpc\models\client_data.py ---

"""
This module defines the ClientData class, a data structure designed to hold comprehensive 
client-related information about a player's session in League of Legends. This class is particularly
useful for tracking real-time client state and player statistics, encapsulating everything from the
current game mode to the player's ranked stats across different game formats.


Usage:
    The ClientData class is integral to systems that require monitoring or displaying real-time information
    about a player’s current game status or session details. It is especially useful in client applications,
    overlays, and tools that provide enhanced player experiences by utilizing live data to offer insights,
    stats tracking, and session analysis.
"""

import time
from dataclasses import dataclass, field

from league_rpc.models.lcu.current_ranked_stats import ArenaStats, RankedStats, TFTStats


@dataclass
class ClientData:
    """Stores data relevant to the player's current session, including their availability,
    game mode, lobby details, and ranked statistics. The class uses the dataclass decorator
    for convenient storage and retrieval of instance data with default values and type annotations.
    """

    availability: str = "Online"  # "Online", "Away
    gamemode: str = ""
    gameflow_phase: str = (
        "None"  # None, Lobby, Matchmaking, ReadyCheck, ChampSelect, InProgress, WaitingForStats, EndOfGame
    )
    is_custom: bool = False
    is_practice: bool = False
    lobby_id: str = ""  # unique lobby id
    map_id: int = 0  # 11, 12, 21, 22, 30
    max_players: int = 0  # max players in lobby
    players: int = 0  # players in lobby
    queue: str = ""
    queue_type: str = ""
    queue_id: int = -1
    queue_is_ranked: bool = False
    summoner_icon: int = 0
    summoner_level: int = 0
    summoner_rank: RankedStats = field(default_factory=RankedStats)
    summoner_rank_flex: RankedStats = field(default_factory=RankedStats)
    arena_rank: ArenaStats = field(default_factory=ArenaStats)
    tft_rank: TFTStats = field(default_factory=TFTStats)
    application_start_time: int = int(time.time())


--- .\presets\league-of-legends\league_rpc\models\module_data.py ---

"""
This module defines the ModuleData class, which holds essential internal state data and connections necessary 
for interacting with the League of Legends client via the LCU (League Client Update) Driver. This class facilitates 
the integration of client data into external applications, particularly those that enhance in-game interactions or 
functionality through additional overlays or tools.

Usage:
    The ModuleData class is integral to applications that interact with the League of Legends client, providing 
    a centralized repository for managing connections and state. It is especially useful in environments where 
    multiple components or services must access or modify the client state or where integration with third-party 
    services like Discord for Rich Presence is required. This setup supports a robust, maintainable codebase 
    by ensuring that essential state and connection information is easily accessible and systematically organized.
"""

from argparse import Namespace
from dataclasses import dataclass, field
from typing import Optional

from lcu_driver.connector import Connector
from pypresence import Presence

from league_rpc.models.client_data import ClientData


# contains module internal data
@dataclass
class ModuleData:
    """A dataclass designed to store the operational state of a module, including connections to the
    League client and the current state of any ongoing Rich Presence integrations.
    """

    connector: Connector = field(default_factory=Connector)
    client_data: ClientData = field(default_factory=ClientData)
    rpc: Optional[Presence] = None
    cli_args: Optional[Namespace] = None


--- .\presets\league-of-legends\league_rpc\models\rpc_updater.py ---

"""
This module provides the RPCUpdater dataclass designed to manage and throttle updates to Discord Rich Presence
based on events occurring within the League of Legends client. The updater focuses on limiting redundant updates
to optimize performance and ensure that the displayed status is current without overwhelming the update mechanism.

Usage:
    RPCUpdater is critical in applications where live updates of user status are necessary, especially in contexts where
    the user's game state changes frequently, such as during matchmaking or in various phases of gameplay. It ensures
    that updates are efficiently managed and that the displayed information remains accurate without excessive updates,
    which could disrupt the user experience or exceed API rate limits.
"""

import time
from dataclasses import dataclass
from threading import Timer

from pypresence import Presence  # type:ignore

from league_rpc.lcu_api.lcu_connector import ModuleData
from league_rpc.models.client_data import ClientData
from league_rpc.models.lcu.current_chat_status import LolChatUser
from league_rpc.models.lcu.current_ranked_stats import ArenaStats, RankedStats, TFTStats
from league_rpc.models.lcu.gameflow_phase import GameFlowPhase
from league_rpc.utils.const import (
    BASE_MAP_ICON_URL,
    GAME_MODE_CONVERT_MAP,
    LEAGUE_OF_LEGENDS_LOGO,
    MAP_ICON_CONVERT_MAP,
    PROFILE_ICON_BASE_URL,
    RANKED_TYPE_MAPPER,
    SMALL_TEXT,
)


# As some events are called multiple times, we should limit the amount of updates to the RPC.
# Collect update events for 1 second and then update the RPC.
@dataclass
class RPCUpdater:
    """A dataclass responsible for scheduling and executing updates to the Discord Rich Presence,
    encapsulating logic to delay and batch update requests to avoid rapid, unnecessary refreshes.
    """

    scheduled_update: bool = False

    def delay_update(self, module_data: ModuleData) -> None:
        """Schedules an update if one is not already scheduled within a short delay (1 second)."""
        if not self.scheduled_update:
            self.scheduled_update = True
            Timer(
                interval=1.0,
                function=self.update_rpc_and_reset_flag,
                args=(module_data,),
            ).start()

    def update_rpc_and_reset_flag(self, module_data: ModuleData) -> None:
        """Executes the update to Rich Presence and resets the scheduling flag."""
        self.update_rpc(
            module_data=module_data
        )  # Assuming update_rpc is defined elsewhere
        self.scheduled_update = False

    @staticmethod
    def in_client_rpc(
        rpc: Presence,
        module_data: ModuleData,
    ) -> None:
        """
        Updates Rich Presence when the user is in the client.
        """
        details: str = f"{module_data.client_data.availability}"
        show_emojis: bool = module_data.cli_args.show_emojis  # type:ignore

        if show_emojis:
            status_emojis: str = (
                f"{'🟢' if module_data.client_data.availability == LolChatUser.ONLINE.capitalize() else '  🔴'}"
            )
            # details = status_emojis + details
            details = status_emojis + "  " + details

        rpc.update(  # type: ignore
            large_image=f"{PROFILE_ICON_BASE_URL}{module_data.client_data.summoner_icon}.png",
            large_text="In Client",
            small_image=LEAGUE_OF_LEGENDS_LOGO,
            small_text=SMALL_TEXT,
            details=details,
            state="In Client",
            start=module_data.client_data.application_start_time,
        )

    @staticmethod
    def in_lobby_rpc(
        rpc: Presence,
        module_data: ModuleData,
        is_custom: bool,
    ) -> None:
        """Updates Rich Presence for lobby status, handling custom and standard lobbies."""
        if is_custom:
            large_image: str = (
                f"{PROFILE_ICON_BASE_URL}{str(module_data.client_data.summoner_icon)}.png"
            )

            large_text: str = (
                f"{GAME_MODE_CONVERT_MAP.get(module_data.client_data.gamemode, module_data.client_data.gamemode)}"
            )
            small_image: str = BASE_MAP_ICON_URL.format(
                map_name=MAP_ICON_CONVERT_MAP.get(module_data.client_data.map_id)
            )
            small_text = SMALL_TEXT

            details: str = f"In Lobby: {module_data.client_data.queue}"
            state = "Custom Lobby"

            rpc.update(  # type: ignore
                large_image=large_image,
                large_text=large_text,
                small_image=small_image,
                small_text=small_text,
                details=details,
                state=state,
                start=module_data.client_data.application_start_time,
            )
        else:
            large_image = f"{PROFILE_ICON_BASE_URL}{str(module_data.client_data.summoner_icon)}.png"

            large_text = f"{GAME_MODE_CONVERT_MAP.get(module_data.client_data.gamemode, module_data.client_data.gamemode)}"

            small_image = BASE_MAP_ICON_URL.format(
                map_name=MAP_ICON_CONVERT_MAP.get(module_data.client_data.map_id)
            )
            small_text = SMALL_TEXT
            details = f"{module_data.client_data.queue}"
            state = f"In Lobby ({module_data.client_data.players}/{module_data.client_data.max_players})"

            if not module_data.cli_args.no_rank:  # type: ignore
                _large_text, _small_image, _small_text = RPCUpdater.show_ranked_data(
                    module_data
                )
                if all([_large_text, _small_image, _small_text]):
                    large_text, small_image, small_text = (
                        _large_text,
                        _small_image,
                        _small_text,
                    )

            rpc.update(  # type: ignore
                large_image=large_image,
                large_text=large_text,
                small_image=small_image,
                small_text=f"{small_text}",
                details=details,
                state=state,
                start=module_data.client_data.application_start_time,
            )

    @staticmethod
    def show_ranked_data(
        module_data: ModuleData,
    ) -> tuple[str, ...]:
        """Helper method to fetch formatted ranked data for display in Rich Presence."""
        large_text = small_text = small_image = ""

        match RANKED_TYPE_MAPPER.get(module_data.client_data.queue_type):
            case "Ranked Solo/Duo":
                summoner_rank: RankedStats = module_data.client_data.summoner_rank  # type: ignore
                if summoner_rank.tier:
                    (
                        small_text,
                        small_image,
                    ) = summoner_rank.rpc_info
                    large_text = SMALL_TEXT

            case "Ranked Flex":
                summoner_rank = module_data.client_data.summoner_rank_flex  # type: ignore
                if summoner_rank.tier:
                    (
                        small_text,
                        small_image,
                    ) = summoner_rank.rpc_info
                    large_text = SMALL_TEXT

            case "Teamfight Tactics (Ranked)":
                summoner_rank: TFTStats = module_data.client_data.tft_rank  # type: ignore
                if summoner_rank.tier:
                    (
                        small_text,
                        small_image,
                    ) = summoner_rank.rpc_info
                    large_text = SMALL_TEXT
            case "Arena":
                summoner_rank: ArenaStats = module_data.client_data.arena_rank  # type: ignore
                if summoner_rank.tier:
                    (
                        small_text,
                        small_image,
                    ) = summoner_rank.rpc_info
                    large_text = SMALL_TEXT

            case _:
                ...
        return large_text, small_image, small_text

    @staticmethod
    def in_queue_rpc(rpc: Presence, module_data: ModuleData) -> None:
        """Updates Rich Presence during the queue phase."""
        large_image: str = (
            f"{PROFILE_ICON_BASE_URL}{module_data.client_data.summoner_icon}.png"
        )
        large_text: str = (
            f"{GAME_MODE_CONVERT_MAP.get(module_data.client_data.gamemode, module_data.client_data.gamemode)}"
        )
        small_image: str = BASE_MAP_ICON_URL.format(
            map_name=MAP_ICON_CONVERT_MAP.get(module_data.client_data.map_id)
        )
        small_text = SMALL_TEXT

        if not module_data.cli_args.no_rank:  # type: ignore
            _large_text, _small_image, _small_text = RPCUpdater.show_ranked_data(
                module_data
            )
            if all([_large_text, _small_image, _small_text]):
                large_text, small_image, small_text = (
                    _large_text,
                    _small_image,
                    _small_text,
                )

        rpc.update(  # type: ignore
            large_image=large_image,
            large_text=large_text,
            small_image=small_image,
            small_text=small_text,
            details=f"{module_data.client_data.queue}",
            state="In Queue",
            start=int(time.time()),
        )

    @staticmethod
    def in_champ_select_rpc(rpc: Presence, module_data: ModuleData) -> None:
        """Updates Rich Presence during champion selection."""
        large_image: str = (
            f"{PROFILE_ICON_BASE_URL}{module_data.client_data.summoner_icon}.png"
        )
        large_text: str = (
            f"{GAME_MODE_CONVERT_MAP.get(module_data.client_data.gamemode, module_data.client_data.gamemode)}"
        )
        small_image: str = BASE_MAP_ICON_URL.format(
            map_name=MAP_ICON_CONVERT_MAP.get(module_data.client_data.map_id)
        )
        small_text = SMALL_TEXT

        if not module_data.cli_args.no_rank:  # type: ignore
            _large_text, _small_image, _small_text = RPCUpdater.show_ranked_data(
                module_data=module_data
            )
            if all([_large_text, _small_image, _small_text]):
                large_text, small_image, small_text = (
                    _large_text,
                    _small_image,
                    _small_text,
                )

        rpc.update(  # type: ignore
            large_image=large_image,
            large_text=large_text,
            small_image=small_image,
            small_text=small_text,
            details=f"{module_data.client_data.queue}",
            state="In Champ Select",
            start=int(time.time()),
        )

    # The function that updates discord rich presence, depending on the data
    def update_rpc(self, module_data: ModuleData) -> None:
        """
        Determines the appropriate Rich Presence status based on the game flow phase and updates Discord.
        """
        data: ClientData = module_data.client_data
        rpc: Presence | None = module_data.rpc

        if not isinstance(rpc, Presence):
            # Only continue if rpc is of type Presence.
            return

        match data.gameflow_phase:
            # This value will be set by "/lol-gameflow/v1/gameflow-phase"

            case GameFlowPhase.IN_PROGRESS:
                # Handled by the "inGame" flow in __main__.py
                return
            case GameFlowPhase.READY_CHECK:
                # When the READY check comes. We want to just ignore (IN_QUEUE rpc will still show.)
                return

            case (
                GameFlowPhase.NONE
                | GameFlowPhase.WAITING_FOR_STATS
                | GameFlowPhase.PRE_END_OF_GAME
                | GameFlowPhase.END_OF_GAME
            ):
                self.in_client_rpc(rpc=rpc, module_data=module_data)
                return
            case GameFlowPhase.CHAMP_SELECT | GameFlowPhase.GAME_START:
                # In Champ Select
                self.in_champ_select_rpc(rpc=rpc, module_data=module_data)
                return
            case GameFlowPhase.MATCHMAKING | GameFlowPhase.READY_CHECK:
                # In Queue
                self.in_queue_rpc(rpc=rpc, module_data=module_data)
                return
            case GameFlowPhase.LOBBY:
                # In Lobby
                if data.is_custom or data.is_practice:
                    self.in_lobby_rpc(rpc=rpc, module_data=module_data, is_custom=True)
                else:
                    # matchmaking lobby
                    self.in_lobby_rpc(rpc=rpc, module_data=module_data, is_custom=False)
                return
            case _:
                # other unhandled gameflow phases
                print(f"Unhandled Gameflow Phase: {data.gameflow_phase}")
                rpc.update(  # type: ignore
                    large_image=f"{PROFILE_ICON_BASE_URL}{str(data.summoner_icon)}.png",
                    large_text=f"{data.gameflow_phase}",
                    small_image=LEAGUE_OF_LEGENDS_LOGO,
                    small_text=SMALL_TEXT,
                    details=f"{data.gameflow_phase}",
                    state="Unhandled Gameflow Phase",
                    start=module_data.client_data.application_start_time,
                )


--- .\presets\league-of-legends\league_rpc\models\__init__.py ---



--- .\presets\league-of-legends\league_rpc\models\lcu\current_chat_status.py ---

"""
This module contains the fields for extracting information from /lol-chat/v1/me
"""


class LolChatUser:
    """
    Represents a user in the League of Legends (LoL) chat system, encapsulating all relevant attributes
    pertaining to a user's profile within the game's chat interface. This class serves as a structured way
    to define and access various constants related to a user's chat properties, such as availability,
    game-related information, identity, and status details.

    Usage:
        This class does not encapsulate behaviors and is utilized primarily for defining and using string constants in a manner that prevents typos and errors in key usage across the chat system implementation.
    """

    AVAILABILITY = "availability"
    GAME_NAME = "gameName"
    GAME_TAG = "gameTag"
    ICON = "icon"
    ID = "id"
    LAST_SEEN_ONLINE_TIMESTAMP = "lastSeenOnlineTimestamp"
    LOL = "lol"  # This is a dictionary with unspecified key-value pairs
    NAME = "name"
    PATCHLINE = "patchline"
    PID = "pid"
    PLATFORM_ID = "platformId"
    PRODUCT = "product"
    PRODUCT_NAME = "productName"
    PUUID = "puuid"
    STATUS_MESSAGE = "statusMessage"
    SUMMARY = "summary"
    SUMMONER_ID = "summonerId"
    TIME = "time"

    AVAILABLE_CHAT_STATUSES = {CHAT := "chat", AWAY := "away", ONLINE := "online"}


--- .\presets\league-of-legends\league_rpc\models\lcu\current_lobby.py ---

"""
This module defines classes for representing various data structures related to the 
League of Legends lobby system. These classes are specifically tailored to encapsulate 
fields extracted from the /lol-lobby/v2/lobby endpoint. Each class is used to organize 
and access data properties critical for managing lobbies, participants, and game configurations 
in a structured manner.

Usage:
    These classes are primarily used for type-safe access to lobby-related data when interacting with the 
    League of Legends client APIs. They provide a clear schema for data manipulation and retrieval, aiding 
    in the development of features that require interaction with lobby configurations and participant management.
"""


class LolLobbyLobbyGameConfigDto:
    """Holds configurations specific to the game setup in a lobby."""

    ALLOWABLE_PREMADE_SIZES = "allowablePremadeSizes"
    CUSTOM_LOBBY_NAME = "customLobbyName"
    CUSTOM_MUTATOR_NAME = "customMutatorName"
    CUSTOM_REWARDS_DISABLED_REASONS = "customRewardsDisabledReasons"
    CUSTOM_SPECTATOR_POLICY = "customSpectatorPolicy"
    CUSTOM_SPECTATORS = "customSpectators"
    CUSTOM_TEAM100 = "customTeam100"
    CUSTOM_TEAM200 = "customTeam200"
    GAME_MODE = "gameMode"
    IS_CUSTOM = "isCustom"
    IS_LOBBY_FULL = "isLobbyFull"
    IS_TEAM_BUILDER_MANAGED = "isTeamBuilderManaged"
    MAP_ID = "mapId"
    MAX_HUMAN_PLAYERS = "maxHumanPlayers"
    MAX_LOBBY_SIZE = "maxLobbySize"
    MAX_TEAM_SIZE = "maxTeamSize"
    PICK_TYPE = "pickType"
    PREMADE_SIZE_ALLOWED = "premadeSizeAllowed"
    QUEUE_ID = "queueId"
    SHOW_POSITION_SELECTOR = "showPositionSelector"


class LolLobbyLobbyParticipantDto:
    """Represents individual participants in the lobby, detailing their permissions and status."""

    ALLOWED_CHANGE_ACTIVITY = "allowedChangeActivity"
    ALLOWED_INVITE_OTHERS = "allowedInviteOthers"
    ALLOWED_KICK_OTHERS = "allowedKickOthers"
    ALLOWED_START_ACTIVITY = "allowedStartActivity"
    ALLOWED_TOGGLE_INVITE = "allowedToggleInvite"
    AUTO_FILL_ELIGIBLE = "autoFillEligible"
    AUTO_FILL_PROTECTED_FOR_PROMOS = "autoFillProtectedForPromos"
    AUTO_FILL_PROTECTED_FOR_SOLOING = "autoFillProtectedForSoloing"
    AUTO_FILL_PROTECTED_FOR_STREAKING = "autoFillProtectedForStreaking"
    BOT_CHAMPION_ID = "botChampionId"
    BOT_DIFFICULTY = "botDifficulty"
    BOT_ID = "botId"
    FIRST_POSITION_PREFERENCE = "firstPositionPreference"
    IS_BOT = "isBot"
    IS_LEADER = "isLeader"
    IS_SPECTATOR = "isSpectator"
    PUUID = "puuid"
    READY = "ready"
    SECOND_POSITION_PREFERENCE = "secondPositionPreference"
    SHOW_GHOSTED_BANNER = "showGhostedBanner"
    SUMMONER_ICON_ID = "summonerIconId"
    SUMMONER_ID = "summonerId"
    SUMMONER_INTERNAL_NAME = "summonerInternalName"
    SUMMONER_LEVEL = "summonerLevel"
    SUMMONER_NAME = "summonerName"
    TEAM_ID = "teamId"


class LolLobbyEligibilityRestriction:
    """Describes eligibility restrictions that may affect participants."""

    EXPIRED_TIMESTAMP = "expiredTimestamp"
    RESTRICTION_ARGS = "restrictionArgs"
    RESTRICTION_CODE = "restrictionCode"
    SUMMONER_IDS = "summonerIds"
    SUMMONER_IDS_STRING = "summonerIdsString"


class LolLobbyLobbyDto:
    """Central class representing the overall lobby structure, including its members and game settings."""

    CAN_START_ACTIVITY = "canStartActivity"
    CHAT_ROOM_ID = "chatRoomId"
    CHAT_ROOM_KEY = "chatRoomKey"
    GAME_CONFIG = "gameConfig"
    INVITATIONS = "invitations"
    LOCAL_MEMBER = "localMember"
    MEMBERS = "members"
    PARTY_ID = "partyId"
    PARTY_TYPE = "partyType"
    RESTRICTIONS = "restrictions"
    WARNINGS = "warnings"


--- .\presets\league-of-legends\league_rpc\models\lcu\current_queue.py ---

"""
This module defines classes that encapsulate configurations and rewards for various game queues
in the League of Legends gaming environment, based on data from the /lol-game-queues/v1/queues/{id} API endpoint.
These classes organize complex game queue settings and reward structures into accessible and manageable properties.

Usage:
    These classes are utilized primarily to provide structured access to game queue data. This organization assists
    developers in implementing features that interact with, modify, or display game queue settings within the League of
    Legends client or associated tools. The classes ensure data integrity and provide a clear interface for
    working with the complex data returned by the game's API.
"""


class LolGameQueuesQueueGameTypeConfig:
    """Manages game type configurations, including rules for picking, banning,
    and match setup parameters specific to each queue.
    """

    ADVANCED_LEARNING_QUESTS = "advancedLearningQuests"
    ALLOW_TRADES = "allowTrades"
    BAN_MODE = "banMode"
    BAN_TIMER_DURATION = "banTimerDuration"
    BATTLE_BOOST = "battleBoost"
    CROSS_TEAM_CHAMPION_POOL = "crossTeamChampionPool"
    DEATH_MATCH = "deathMatch"
    DO_NOT_REMOVE = "doNotRemove"
    DUPLICATE_PICK = "duplicatePick"
    EXCLUSIVE_PICK = "exclusivePick"
    GAME_MODE_OVERRIDE = "gameModeOverride"
    ID = "id"
    LEARNING_QUESTS = "learningQuests"
    MAIN_PICK_TIMER_DURATION = "mainPickTimerDuration"
    MAX_ALLOWABLE_BANS = "maxAllowableBans"
    NAME = "name"
    NUM_PLAYERS_PER_TEAM_OVERRIDE = "numPlayersPerTeamOverride"
    ONBOARD_COOP_BEGINNER = "onboardCoopBeginner"
    PICK_MODE = "pickMode"
    POST_PICK_TIMER_DURATION = "postPickTimerDuration"
    REROLL = "reroll"
    TEAM_CHAMPION_POOL = "teamChampionPool"


class LolGameQueuesQueueReward:
    """Details the reward configurations available per game queue, such as XP and IP earnings."""

    IS_CHAMPION_POINTS_ENABLED = "isChampionPointsEnabled"
    IS_IP_ENABLED = "isIpEnabled"
    IS_XP_ENABLED = "isXpEnabled"
    PARTY_SIZE_IP_REWARDS = "partySizeIpRewards"


class LolGameQueuesQueue:
    """Represents the main structure of a game queue, including its operational parameters,
    such as team settings, champion requirements, and queue availability.
    """

    ALLOWABLE_PREMADE_SIZES = "allowablePremadeSizes"
    ARE_FREE_CHAMPIONS_ALLOWED = "areFreeChampionsAllowed"
    ASSET_MUTATOR = "assetMutator"
    CATEGORY = "category"
    CHAMPIONS_REQUIRED_TO_PLAY = "championsRequiredToPlay"
    DESCRIPTION = "description"
    DETAILED_DESCRIPTION = "detailedDescription"
    GAME_MODE = "gameMode"
    GAME_TYPE_CONFIG = "gameTypeConfig"
    ID = "id"
    IS_RANKED = "isRanked"
    IS_TEAM_BUILDER_MANAGED = "isTeamBuilderManaged"
    IS_TEAM_ONLY = "isTeamOnly"
    LAST_TOGGLED_OFF_TIME = "lastToggledOffTime"
    LAST_TOGGLED_ON_TIME = "lastToggledOnTime"
    MAP_ID = "mapId"
    MAX_DIVISION_FOR_PREMADE_SIZE2 = "maxDivisionForPremadeSize2"
    MAX_LEVEL = "maxLevel"
    MAX_SUMMONER_LEVEL_FOR_FIRST_WIN_OF_THE_DAY = "maxSummonerLevelForFirstWinOfTheDay"
    MAX_TIER_FOR_PREMADE_SIZE2 = "maxTierForPremadeSize2"
    MAXIMUM_PARTICIPANT_LIST_SIZE = "maximumParticipantListSize"
    MIN_LEVEL = "minLevel"
    MINIMUM_PARTICIPANT_LIST_SIZE = "minimumParticipantListSize"
    NAME = "name"
    NUM_PLAYERS_PER_TEAM = "numPlayersPerTeam"
    QUEUE_AVAILABILITY = "queueAvailability"
    QUEUE_REWARDS = "queueRewards"
    REMOVAL_FROM_GAME_ALLOWED = "removalFromGameAllowed"
    REMOVAL_FROM_GAME_DELAY_MINUTES = "removalFromGameDelayMinutes"
    SHORT_NAME = "shortName"
    SHOW_POSITION_SELECTOR = "showPositionSelector"
    SPECTATOR_ENABLED = "spectatorEnabled"
    TYPE = "type"


--- .\presets\league-of-legends\league_rpc\models\lcu\current_ranked_stats.py ---

"""
This module defines data structures for handling ranked statistics in League of Legends,
specifically tailored to interface with the /lol-ranked/v1/current-ranked-stats API endpoint. 
It provides a structured way to parse, organize, and display ranked data across different game modes
within the game, ensuring that data is accessible and usable within other components of a League client or tool.

Usage:
    These classes are essential for constructing a clear, organized view of a player's ranked status across different
    game modes in League of Legends. They facilitate the extraction and transformation of JSON data from the API
    into Python objects that can be easily manipulated and displayed, supporting features such as live display updates,
    statistical analysis, and integration with other systems or user interfaces.
"""

from dataclasses import dataclass
from typing import Any, Optional

from league_rpc.utils.const import LEAGUE_CHERRY_RANKED_EMBLEM, LEAGUE_RANKED_EMBLEM


class LolRankedRankedQueueWarnings:
    """Holds fields related to warnings about ranked queue statuses,
    such as decay warnings and demotion risks.
    """

    DAYS_UNTIL_DECAY = "daysUntilDecay"
    DEMOTION_WARNING = "demotionWarning"
    DISPLAY_DECAY_WARNING = "displayDecayWarning"
    TIME_UNTIL_INACTIVITY_STATUS_CHANGES = "timeUntilInactivityStatusChanges"


class LolRankedRankedQueueStats:
    """Contains detailed statistics and configurations for an individual ranked queue,
    including division, wins, losses, and league points.
    """

    DIVISION = "division"
    IS_PROVISIONAL = "isProvisional"
    LEAGUE_POINTS = "leaguePoints"
    LOSSES = "losses"
    MINI_SERIES_PROGRESS = "miniSeriesProgress"
    PREVIOUS_SEASON_ACHIEVED_DIVISION = "previousSeasonAchievedDivision"
    PREVIOUS_SEASON_ACHIEVED_TIER = "previousSeasonAchievedTier"
    PREVIOUS_SEASON_END_DIVISION = "previousSeasonEndDivision"
    PREVIOUS_SEASON_END_TIER = "previousSeasonEndTier"
    PROVISIONAL_GAME_THRESHOLD = "provisionalGameThreshold"
    PROVISIONAL_GAMES_REMAINING = "provisionalGamesRemaining"
    QUEUE_TYPE = "queueType"
    RATED_RATING = "ratedRating"
    RATED_TIER = "ratedTier"
    TIER = "tier"
    WARNINGS = "warnings"
    WINS = "wins"


class LolRankedRankedStats:
    """Aggregates ranked statistics across multiple queues and tracks overall progress and rewards."""

    EARNED_REGALIA_REWARD_IDS = "earnedRegaliaRewardIds"
    HIGHEST_PREVIOUS_SEASON_ACHIEVED_DIVISION = "highestPreviousSeasonAchievedDivision"
    HIGHEST_PREVIOUS_SEASON_ACHIEVED_TIER = "highestPreviousSeasonAchievedTier"
    HIGHEST_PREVIOUS_SEASON_END_DIVISION = "highestPreviousSeasonEndDivision"
    HIGHEST_PREVIOUS_SEASON_END_TIER = "highestPreviousSeasonEndTier"
    HIGHEST_RANKED_ENTRY = "highestRankedEntry"
    HIGHEST_RANKED_ENTRY_SR = "highestRankedEntrySR"
    QUEUE_MAP = "queueMap"
    QUEUES = "queues"
    RANKED_REGALIA_LEVEL = "rankedRegaliaLevel"
    SEASONS = "seasons"
    SPLITS_PROGRESS = "splitsProgress"

    # Constructor and other methods as needed


@dataclass
class RankedStats:
    """A dataclass to encapsulate specific ranked statistics for standard ranked queues,
    providing methods for easy initialization from API data and formatted string representation.
    """

    division: Optional[str] = None
    tier: Optional[str] = None
    league_points: Optional[int] = None

    @classmethod
    def from_map(
        cls,
        obj_map: dict[str, Any],
        ranked_type: str,
    ) -> "RankedStats":
        return cls(
            division=obj_map[LolRankedRankedStats.QUEUE_MAP][ranked_type][
                LolRankedRankedQueueStats.DIVISION
            ],
            tier=obj_map[LolRankedRankedStats.QUEUE_MAP][ranked_type][
                LolRankedRankedQueueStats.TIER
            ].capitalize(),
            league_points=obj_map[LolRankedRankedStats.QUEUE_MAP][ranked_type][
                LolRankedRankedQueueStats.LEAGUE_POINTS
            ],
        )

    def __str__(self) -> str:
        return f"{self.tier} {self.division}: {self.league_points} LP".strip()

    @property
    def rpc_info(self) -> tuple[str, str]:
        small_text = f"{self}"
        small_image = LEAGUE_RANKED_EMBLEM.format_map({"tier": self.tier})
        return small_text, small_image


@dataclass
class ArenaStats:
    """Similar to RankedStats, but tailored for the Arena (Project Cherry) ranked mode,
    including unique fields and mappings specific to this mode.
    """

    rated_tier: Optional[str] = None
    tier: Optional[str] = None
    rated_rating: Optional[int] = None

    tier_label_mapper = {
        "NONE": "",
        "GRAY": "Wood",
        "GREEN": "Bronze",
        "BLUE": "Silver",
        "PURPLE": "Gold",
        "ORANGE": "Gladiator",
    }

    @classmethod
    def from_map(
        cls,
        obj_map: dict[str, Any],
        ranked_type: str = "CHERRY",
    ) -> "ArenaStats":
        if not obj_map[LolRankedRankedStats.QUEUE_MAP].get(ranked_type):
            # Arena (CHERRY) is not always available to play.
            # So when it's not, we make an early return of an instance with default values.
            return cls()

        rated_tier = obj_map[LolRankedRankedStats.QUEUE_MAP][ranked_type][
            LolRankedRankedQueueStats.RATED_TIER
        ]
        return cls(
            rated_tier=rated_tier,
            tier=cls.tier_label_mapper[rated_tier],
            rated_rating=obj_map[LolRankedRankedStats.QUEUE_MAP][ranked_type][
                LolRankedRankedQueueStats.RATED_RATING
            ],
        )

    def __str__(self) -> str:
        return f"{self.tier} • Rating: {self.rated_rating}".strip()

    @property
    def rpc_info(self) -> tuple[str, str]:
        small_text = f"{self}"
        small_image = LEAGUE_CHERRY_RANKED_EMBLEM.format_map({"tier": self.tier})
        return small_text, small_image


@dataclass
class TFTStats:
    """A dataclass for encapsulating Teamfight Tactics (TFT) ranked data, structured similarly to RankedStats,
    with methods for data extraction and formatted output.
    """

    division: Optional[str] = None
    league_points: Optional[int] = None
    tier: Optional[str] = None

    @classmethod
    def from_map(
        cls,
        obj_map: dict[str, Any],
        ranked_type: str = "RANKED_TFT",
    ) -> "TFTStats":
        return cls(
            division=obj_map[LolRankedRankedStats.QUEUE_MAP][ranked_type][
                LolRankedRankedQueueStats.DIVISION
            ],
            league_points=obj_map[LolRankedRankedStats.QUEUE_MAP][ranked_type][
                LolRankedRankedQueueStats.LEAGUE_POINTS
            ],
            tier=obj_map[LolRankedRankedStats.QUEUE_MAP][ranked_type][
                LolRankedRankedQueueStats.TIER
            ].capitalize(),
        )

    def __str__(self) -> str:
        return f"{self.tier} {self.division}: {self.league_points} LP".strip()

    @property
    def rpc_info(self) -> tuple[str, str]:
        small_text = f"{self}"
        small_image = LEAGUE_RANKED_EMBLEM.format_map({"tier": self.tier})
        return small_text, small_image


--- .\presets\league-of-legends\league_rpc\models\lcu\current_summoner.py ---

"""
This module defines a class that encapsulates information about a summoner in League of Legends,
specifically for interfacing with the /lol-summoner/v1/current-summoner API endpoint. It structures
the data associated with a summoner's account, providing an organized way to access properties such
as display name, level, profile icon, and experience points.

Usage:
    This class serves as a centralized resource for retrieving and manipulating summoner data within
    applications. It is particularly useful in League of Legends client tools, where displaying up-to-date
    summoner information or interacting with the client's features requires accurate and organized data.
    The fields in this class can be used to map JSON data from the API into Python objects for further processing
    or display, facilitating easy access and manipulation of summoner-specific information.
"""


class Summoner:
    """Contains constants for key fields extracted from the summoner data endpoint,
    including identifiers, level information, and details on customization points (reroll points)
    used in certain game modes like ARAM (All Random All Mid).
    """

    ACCOUNT_ID = "accountId"
    DISPLAY_NAME = "displayName"
    INTERNAL_NAME = "internalName"
    NAME_CHANGE_FLAG = "nameChangeFlag"
    PERCENT_COMPLETE_FOR_NEXT_LEVEL = "percentCompleteForNextLevel"
    PRIVACY = "privacy"
    PROFILE_ICON_ID = "profileIconId"
    PUUID = "puuid"
    REROLL_POINTS = "rerollPoints"
    CURRENT_POINTS = "currentPoints"
    MAX_ROLL = "maxRolls"
    NUMBER_OF_ROLLS = "numberOfRolls"
    POINTS_COST_TO_ROLL = "pointsCostToRoll"
    SUMMONER_ID = "summonerId"
    SUMMONER_LEVEL = "summonerLevel"
    UNNAMED = "unnamed"
    XP_SINCE_LAST_LEVEL = "xpSinceLastLevel"
    XP_UNTIL_NEXT_LEVEL = "xpUntilNextLevel"


--- .\presets\league-of-legends\league_rpc\models\lcu\gameflow_phase.py ---

"""
This module defines classes for encapsulating various stages of the game flow and lobby/player statuses 
in League of Legends, interfacing with two specific API endpoints: /lol-summoner/v1/current-summoner 
for game flow phases and /lol-gameflow/v1/gameflow-metadata/player-status for lobby and player statuses. 
These classes organize data relevant to game progression and lobby management, ensuring it can be accessed 
and manipulated efficiently.

Usage:
    These classes are crucial for developing features that require tracking or responding to changes in the game's 
    status or managing interactions within the game lobby. They facilitate the creation of responsive and interactive 
    features in client tools, enhancing the user experience by providing real-time updates and controls based on the 
    game flow and lobby conditions. This structured approach helps maintain clarity and consistency when interacting 
    with the related APIs, supporting a robust development environment for League of Legends client applications.
"""


class GameFlowPhase:
    """Enumerates all possible phases of the game flow, from lobby formation to the end of a game,
    providing clear constants to represent each phase of gameplay.
    """

    NONE = "None"
    LOBBY = "Lobby"
    MATCHMAKING = "Matchmaking"
    CHECKED_INTO_TOURNAMENT = "CheckedIntoTournament"
    READY_CHECK = "ReadyCheck"
    CHAMP_SELECT = "ChampSelect"
    GAME_START = "GameStart"
    FAILED_TO_LAUNCH = "FailedToLaunch"
    IN_PROGRESS = "InProgress"
    RECONNECT = "Reconnect"
    WAITING_FOR_STATS = "WaitingForStats"
    PRE_END_OF_GAME = "PreEndOfGame"
    END_OF_GAME = "EndOfGame"
    TERMINATED_IN_ERROR = "TerminatedInError"


class LolGameflowLobbyStatus:
    """Contains attributes that describe the status of a game lobby, including whether
    it's a custom game, the lobby's queue ID, and details about its members and spectators.
    """

    ALLOWED_PLAY_AGAIN = "allowedPlayAgain"
    CUSTOM_SPECTATOR_POLICY = "customSpectatorPolicy"
    INVITED_SUMMONER_IDS = "invitedSummonerIds"
    IS_CUSTOM = "isCustom"
    IS_LEADER = "isLeader"
    IS_PRACTICE_TOOL = "isPracticeTool"
    IS_SPECTATOR = "isSpectator"
    LOBBY_ID = "lobbyId"
    MEMBER_SUMMONER_IDS = "memberSummonerIds"
    QUEUE_ID = "queueId"


class LolGameflowPlayerStatus:
    """Holds fields related to the player's status within the game flow, detailing their
    ability to invite others post-game and status of their current and last queued lobbies.
    """

    CAN_INVITE_OTHERS_AT_EOG = "canInviteOthersAtEog"
    CURRENT_LOBBY_STATUS = "currentLobbyStatus"
    LAST_QUEUED_LOBBY_STATUS = "lastQueuedLobbyStatus"


--- .\presets\league-of-legends\league_rpc\models\lcu\__init__.py ---



--- .\presets\league-of-legends\league_rpc\processes\process.py ---

import sys
import time
from argparse import Namespace

import psutil
import pypresence  # type:ignore

from league_rpc.disable_native_rpc.disable import check_and_modify_json, find_game_path
from league_rpc.utils.color import Color
from league_rpc.utils.launch_league import launch_league_client


def processes_exists(process_names: list[str]) -> bool:
    """
    Given an array of process names.
    Give a boolean return value if any of the names was a running process in the machine.
    """
    return any(process_exists(process_name) for process_name in process_names)


def process_exists(process_name: str) -> bool:
    """
    Checks if the given process name is running or not.
    """
    for proc in psutil.process_iter():
        try:
            if process_name.lower() in proc.name().lower():
                return True
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    return False


def check_league_client_process(cli_args: Namespace) -> None:
    """
    Checks league client processes.
    """
    league_processes: list[str] = ["LeagueClient.exe", "LeagueClientUx.exe"]

    print(f"{Color.yellow}Checking if LeagueClient.exe is running...")
    time.sleep(1)

    if cli_args.launch_league:
        # launch league if it's not already running.
        if not processes_exists(league_processes):
            launch_league_client(cli_args)

    if not processes_exists(process_names=league_processes):
        # If league process is still not running, even after launching the client.
        # Then something must have gone wrong.
        # Do not exit app, but rather wait for user to open the correct game..
        if cli_args.wait_for_league == -1:
            print(
                f"{Color.yellow}Will wait {Color.green}indefinitely{Color.yellow} for League to start... Remember, forever is a long time.. use {Color.green}CTRL + C{Color.yellow} if you would like to quit.{Color.reset}"
            )

    wait_time = 0
    while True:
        if not processes_exists(process_names=league_processes):
            if process_exists(process_name="RiotClientServices.exe"):
                # Disable native RPC only if the RiotClientService.exe is running,
                # but not the league client.
                if game_path := find_game_path():
                    check_and_modify_json(file_path=game_path)
                else:
                    print(
                        f"{Color.red} Did not find the game path for league.. Can't disable the native RPC.{Color.reset}"
                    )
            if cli_args.wait_for_league == -1:
                continue
            elif wait_time >= cli_args.wait_for_league:
                print(
                    f"{Color.red}League Client is not running! Exiting after waiting {cli_args.wait_for_league} seconds.{Color.reset}"
                )
                if not cli_args.wait_for_league:
                    print(
                        f"{Color.green}Want to add waiting time for League? Use --wait-for-league <seconds>. (-1 = infinite, or until CTRL + C)"
                    )
                sys.exit()
            else:
                print(
                    f"{Color.yellow}Will wait for League to start. Time left: {cli_args.wait_for_league - wait_time} seconds..."
                )
                time.sleep(5)
                wait_time += 5
                continue
        break

    print(f"{Color.green}League client is running!{Color.dgray}(1/2){Color.reset}")


def check_discord_process(
    process_names: list[str], client_id: str, wait_for_discord: int
) -> pypresence.Presence:
    """
    Checks if discord process is running.
    Connects to Discord Rich Presence if it is found.
    """
    print(f"\n{Color.yellow}Checking if Discord is running...{Color.reset}")

    look_for_processes = f"({Color.green}{', '.join(process_names)}{Color.blue})"

    time.sleep(1)

    if wait_for_discord == -1:
        print(
            f"{Color.yellow}Will wait {Color.green}indefinitely{Color.yellow} for Discord to start... Remember, forever is a long time.. use {Color.green}CTRL + C{Color.yellow} if you would like to quit.{Color.reset}"
        )

    wait_time = 0
    while True:
        if not processes_exists(process_names=process_names):
            if wait_for_discord == -1:
                time.sleep(10)
                continue
            elif wait_time >= wait_for_discord:
                print(
                    f"""{Color.red}Discord not running!
            {Color.blue}Could not find any process with the names {look_for_processes} running on your system.
            Is your Discord process named something else? Try --add-process <name>{Color.reset}"""
                )

                if not wait_for_discord:
                    print(
                        f"{Color.green}Want to add waiting time for discord? Use --wait-for-discord <seconds>. (-1 = infinite, or until CTRL + C)"
                    )
                sys.exit()
            else:
                print(
                    f"{Color.yellow}Will wait for Discord to start. Time left: {wait_for_discord - wait_time} seconds..."
                )
                time.sleep(5)
                wait_time += 5
                continue
        break

    print(f"{Color.green}Discord is running! {Color.dgray}(2/2){Color.reset}")

    for _ in range(5):
        time.sleep(3)
        try:
            rpc = pypresence.Presence(client_id)
            rpc.connect()
            break
        except pypresence.exceptions.InvalidID:
            print(
                f"{Color.red}Invalid Client ID. Make sure your Discord Application ID is correct."
            )
            sys.exit()
        except pypresence.exceptions.DiscordError:
            # Sometimes when starting discord, an error can occur saying that you logged out.
            # Weird but can be ignored since it usually works a second or so after.
            time.sleep(1)
            continue
        except pypresence.exceptions.DiscordNotFound:
            # Sometimes when starting discord, an error can occur saying that you logged out.
            # Weird but can be ignored since it usually works a second or so after.
            print(
                f"{Color.red}Pypresence (RPC) Could not find Discord installed and running on this machine."
            )
            sys.exit()
        except pypresence.exceptions.PipeClosed:
            # The pipe was closed. Catch this exception and re-connect your instance
            time.sleep(1)
            continue
        except ConnectionRefusedError:
            print(
                f"""
            {Color.red}PyPresence encountered some problems, and could not connect to your Discord's RPC
            {Color.blue}Try to restart Discord (Close the application from your Task Manager).{Color.reset}
                """
            )

            ############################################################
            # Legacy code.. This was implemented for Linux users only. #
            ############################################################
            # print(
            #     f"""
            # {Colors.red}PyPresence encountered some problems, and could not connect to your Discord's RPC
            # {Colors.blue}
            # 1. One or more of the processes this script was looking for was found {look_for_processes}
            #     But Pypresence still was unable to detect a running discord-ipc
            # 2. You may not have a discord ipc running. Try {Colors.reset}``{Colors.green}ls $XDG_RUNTIME_DIR | grep discord-ipc-{Colors.reset}``{Colors.blue} There should only be one result {Colors.reset}``{Colors.green}discord-ipc-0={Colors.reset}``
            # {Colors.blue}3. Try restarting Discord. (Make sure the process is stopped before doing that.){Colors.reset}
            #     """
            # )

            # # If process names were not found, but ipc exists. Try removing them & restarting
            # if len((val := check_discord_ipc())) > 1:
            #     print(
            #         f"""
            #     {Colors.red}Detected multiple ipc's running.{Colors.reset}
            #     You seem to have more than 1 ipc running (which is unusual).
            #     If you know that discord is running, but pypresence keep failing to connect.
            #     It might be cause you have multiple ipc's running. try removing the following ipc's and {Colors.green}restart discord.{Colors.reset}
            #     {Colors.yellow}ipc's: {' , '.join(val)}{Colors.reset}
            #     run: ``{Colors.green}rm  {' '.join(val)}{Colors.reset}``
            #     Or you just don't have discord up and running..
            #             """
            #     )
            print(
                f"{Color.red}Raising Exception found by PyPresence, and exiting..{Color.reset}"
            )
            sys.exit()
    else:
        print(
            f"{Color.red}Discord process was found but RPC could not be connected.{Color.reset}"
        )
        sys.exit()
    return rpc


############################################################
# Legacy code.. This was implemented for Linux users only. #
############################################################
# def check_discord_ipc() -> list[str]:
#     """
#     Checks if there are any discord-ipc's running.
#     """
#     # Path to check for Discord IPC sockets

#     xdg_runtime_dir = os.environ.get("XDG_RUNTIME_DIR")

#     if not xdg_runtime_dir:
#         # If for some reason this environmental variable is not set.. just ignore this function.
#         return []

#     ipc_pattern = "discord-ipc-*"
#     list_of_ipcs: list[str] = []

#     for ipc_socket in glob.glob(os.path.join(xdg_runtime_dir, ipc_pattern)):
#         if os.path.exists(ipc_socket):
#             list_of_ipcs.append(ipc_socket)
#     return list_of_ipcs


def player_state() -> str | None:
    """
    Returns the player state
    """
    current_state: str | None = None

    if processes_exists(process_names=["LeagueClient.exe", "LeagueClientUx.exe"]):
        if process_exists(process_name="League of Legends.exe"):
            current_state = "InGame"
        else:
            current_state = "InLobby"
    return current_state


--- .\presets\league-of-legends\league_rpc\processes\__init__.py ---



--- .\presets\league-of-legends\league_rpc\utils\color.py ---

"""
This module holds the Colors class and related functionalities around it.
"""

from dataclasses import dataclass

from league_rpc.__version__ import (
    RELEASES_PAGE,
    __version__,
    check_latest_version,
    get_version_from_github,
)


@dataclass
class Color:
    """
    Dataclass, storing the different colors that is used in the program.
    """

    dred: str = "\033[31m"
    dgreen: str = "\033[32m"
    yellow: str = "\033[33m"
    dblue: str = "\033[34m"
    dmagenta: str = "\033[35m"
    dcyan: str = "\033[36m"
    lgrey: str = "\033[37m"
    dgray: str = "\033[90m"
    red: str = "\033[91m"
    green: str = "\033[92m"
    orange: str = "\033[93m"
    blue: str = "\033[94m"
    magenta: str = "\033[95m"
    cyan: str = "\033[96m"
    white: str = "\033[97m"
    reset: str = "\033[0m"

    @property
    def logo(self) -> str:
        """Just prints the LEAGUE rpc logo, in your favorite Terminal Emulator."""

        return rf"""
        {self.yellow}  _                                  {self.dblue} _____  _____   _____ {self.reset}
        {self.yellow} | |                                 {self.dblue}|  __ \|  __ \ / ____|{self.reset}
        {self.yellow} | |     ___  __ _  __ _ _   _  ___  {self.dblue}| |__) | |__) | |     {self.reset}
        {self.yellow} | |    / _ \/ _` |/ _` | | | |/ _ \ {self.dblue}|  _  /|  ___/| |     {self.reset}
        {self.yellow} | |___|  __/ (_| | (_| | |_| |  __/ {self.dblue}| | \ \| |    | |____ {self.reset}
        {self.yellow} |______\___|\__,_|\__, |\__,_|\___| {self.dblue}|_|  \_\_|     \_____|{self.reset}
        {self.yellow}                    __/ |                                              {self.reset}
        {self.yellow}                   |___/ By @Haze.dev - (Version: {self.green if not check_latest_version() else self.red}{__version__}{self.yellow})       {self.reset}
        {f'{self.yellow} A newer version is available at {RELEASES_PAGE} {self.green}[{get_version_from_github()}]{self.reset}' if check_latest_version() else ""}
        """


--- .\presets\league-of-legends\league_rpc\utils\const.py ---

# Discord Application: League of Legends
DEFAULT_CLIENT_ID = "1194034071588851783"
DISCORD_PROCESS_NAMES: list[str] = [
    "Discord",
    "DiscordPTB",
    "DiscordCanary",
    "electron",
]
LEAGUE_OF_LEGENDS_LOGO = "https://github.com/Its-Haze/league-rpc/blob/master/assets/leagueoflegends.png?raw=true"
SMALL_TEXT = "github.com/Its-Haze/league-rpc"

ALL_GAME_DATA_URL = "https://127.0.0.1:2999/liveclientdata/allgamedata"

ACTIVE_PLAYER_URL = "https://127.0.0.1:2999/liveclientdata/activeplayer"

PLAYER_KDA_SCORES_URL = (
    "https://127.0.0.1:2999/liveclientdata/playerscores?riotId={riotId}"
)

BASE_SKIN_URL = "https://ddragon.leagueoflegends.com/cdn/img/champion/tiles/"

BASE_MAP_ICON_URL = "https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/content/src/leagueclient/gamemodeassets/{map_name}/img/game-select-icon-active.png"

PROFILE_ICON_BASE_URL = (
    "https://raw.communitydragon.org/latest/game/assets/ux/summonericons/profileicon"
)

DDRAGON_CHAMPION_DATA = "https://ddragon.leagueoflegends.com/cdn/{version}/data/{locale}/champion/{name}.json"

MERAKIANALYTICS_CHAMPION_DATA = (
    "https://cdn.merakianalytics.com/riot/lol/resources/latest/{locale}/champions.json"
)

DDRAGON_API_VERSIONS = "https://ddragon.leagueoflegends.com/api/versions.json"

MAP_ICON_CONVERT_MAP: dict[int, str] = {
    11: "classic_sru",
    12: "aram",
    21: "gamemodex",
    22: "tft",
    30: "cherry",
    33: "strawberry",
}


GAME_MODE_CONVERT_MAP: dict[str, str] = {
    "PRACTICETOOL": "Summoner's Rift (Custom)",
    "ARAM": "Howling Abyss (ARAM)",
    "CLASSIC": "Summoner's Rift",
    "TUTORIAL": "Summoner's Rift (Tutorial)",
    "URF": "Summoner's Rift (URF)",
    "NEXUSBLITZ": "Nexux Blitz",
    "CHERRY": "Arena",
    "STRAWBERRY": "Swarm - PVE",
    "TUTORIAL_MODULE_3": "Summoner's Rift (Tutorial)",
    "TUTORIAL_MODULE_2": "Summoner's Rift (Tutorial)",
    "TUTORIAL_MODULE_1": "Summoner's Rift (Tutorial)",
}

CHAMPION_NAME_CONVERT_MAP = {
    "AurelionSol": "Aurelion Sol",
    "Belveth": "Bel'Veth",
    "Chogath": "Cho'Gath",
    "DrMundo": "Dr. Mundo",
    "JarvanIV": "Jarvan IV",
    "Kaisa": "Kai'Sa",
    "Khazix": "Kha'Zix",
    "KogMaw": "Kog'Maw",
    "KSante": "K'Sante",
    "LeeSin": "Lee Sin",
    "MasterYi": "Master Yi",
    "MissFortune": "Miss Fortune",
    "Nunu": "Nunu & Willump",
    "RekSai": "Rek'Sai",
    "Renata": "Renata Glasc",
    "TahmKench": "Tahm Kench",
    "TwistedFate": "Twisted Fate",
    "Velkoz": "Vel'Koz",
    "MonkeyKing": "Wukong",
    "XinZhao": "Xin Zhao",
}

LEAGUE_RANKED_EMBLEM = "https://github.com/Its-Haze/league-assets/blob/master/ranked_emblems/{tier}.png?raw=true"
LEAGUE_CHERRY_RANKED_EMBLEM = "https://github.com/Its-Haze/league-assets/blob/master/cherry_rated_medallions/{tier}.png?raw=true"


RANKED_TYPE_MAPPER = {
    "RANKED_SOLO_5x5": "Ranked Solo/Duo",
    "RANKED_FLEX_SR": "Ranked Flex",
    "RANKED_TFT": "Teamfight Tactics (Ranked)",
    "RANKED_TFT_DOUBLE_UP": "Teamfight Tactics (Double Up Workshop)",
    "RANKED_TFT_TURBO": "Teamfight Tactics (Hyper Roll)",
    "CHERRY": "Arena",
}

DEFAULT_LEAGUE_CLIENT_EXE_PATH = "C:\\Riot Games\\Riot Client\\RiotClientServices.exe"
DEFAULT_LEAGUE_CLIENT_EXECUTABLE = "RiotClientServices.exe"


--- .\presets\league-of-legends\league_rpc\utils\launch_league.py ---

import subprocess
import time
from argparse import Namespace

from league_rpc.utils.const import DEFAULT_LEAGUE_CLIENT_EXECUTABLE


def launch_league_client(cli_args: Namespace) -> None:
    """Launch the League Client with the given path or the default path."""

    # If the user wants to launch the league client.
    # we should use the path given by the user to launch the client with subprocess.
    if DEFAULT_LEAGUE_CLIENT_EXECUTABLE in cli_args.launch_league:
        # If the default path is given, use the default launch arguments for league.
        commands = [
            cli_args.launch_league,
            "--launch-product=league_of_legends",
            "--launch-patchline=live",
        ]
    else:
        # If a custom path has been set, just execute that path
        commands = [cli_args.launch_league]

    subprocess.Popen(commands, shell=True)
    time.sleep(5)


--- .\presets\league-of-legends\league_rpc\utils\polling.py ---

import time

import requests
from urllib3.exceptions import NewConnectionError


def wait_until_exists(
    url: str,
    custom_message: str = "",
    expected_response_code: int = 200,
    timeout: int = 30,
    n_sleep: float | int = 5,  # Not needed, but good to have.
    n_total_amount: int = 20,
    startup: int = False,  # Set to True on the first time it tries to poll the local api. (onGameStart)
) -> requests.Response | None:
    """
    Polling on the local riot api until success is returned.
    """

    for _ in range(n_total_amount):
        try:
            response = requests.get(url, timeout=timeout, verify=False)
            if response.status_code != expected_response_code:
                time.sleep(n_sleep)
                continue
            break
        except (
            NewConnectionError,
            ConnectionError,
            requests.exceptions.ConnectionError,
        ):
            # These errors occur either before the api has started..
            # Or when the game has ended
            if startup:
                # Make sure we continue to poll the api during the start of a game.
                time.sleep(n_sleep)
                continue

            # When game ends, we don't care about polling the api.
            return None
    else:
        print(custom_message)
        return None
    return response


--- .\presets\roblox\README.md ---

# Discord RPC for [Universal-Discord-Rich-Presence](https://github.com/Purple-Palm/Universal-Discord-Rich-Presence)

Script that displays Discord Rich Presence while Roblox window is Focused.

This code is Forked and edited according to the needs for project.

![Preview](https://github.com/mengdeveloper/RobloxDiscordRPC/assets/53615275/709d6070-ca86-4713-8bf3-926a2be96733)



--- .\presets\roblox\requirements.txt ---

c e r t i f i 
 
 c h a r s e t - n o r m a l i z e r 
 
 i d n a 
 
 i n q u i r e r p y 
 
 p f z y 
 
 p r o m p t _ t o o l k i t 
 
 p s u t i l 
 
 p y p r e s e n c e 
 
 p y w i n 3 2 
 
 P y Y A M L 
 
 r e q u e s t s 
 
 u r l l i b 3 
 
 w c w i d t h 
 
 

--- .\presets\roblox\RobloxPlayerBeta.py ---

from pypresence import Presence
from InquirerPy.utils import color_print
import glob, urllib, requests, json, os, time, win32gui, win32process, random , psutil, os, yaml

# Get data between lines of Roblox logs
def find_between(s, first, last):
    try:
        start = s.index( first ) + len( first )
        end = s.index( last, start )
        return s[start:end]
    except ValueError:
        return ""

# Check if roblox window is in focus 
def check_roblox_focus():
        def get_active_window_process_name():
            hwnd = win32gui.GetForegroundWindow()
            _, pid = win32process.GetWindowThreadProcessId(hwnd)
            for proc in psutil.process_iter(['pid', 'name']):
                if proc.info['pid'] == pid:
                    return proc.info['name']
            return None

        # Exit the script in case window is not focused
        active_window_process = get_active_window_process_name()
        if active_window_process != "RobloxPlayerBeta.exe":
            exit_roblox_rpc()
        return True

# Exit the script 
def exit_roblox_rpc():
    #subprocess.Popen([sys.executable, "main.py"])
    print('leaving roblox rpc')
    os._exit(1)

# Get path to user folder
def getUser():
    return os.environ['USERPROFILE'].replace("C:\\Users\\", "")

# Load latest Roblox log file by creation time
def getCacheLog():
    list_of_files = glob.glob("C:\\Users\\" + getUser() + "\\AppData\\Local\\Roblox\\logs" + "\*.log") # get data about all .log files
    latest_file = max(list_of_files, key=os.path.getctime) # Get path to a latest created Roblox log file
    fin = open(latest_file, "r", encoding = "ISO-8859-1").readlines() # Open log file
    return fin

# Get required values from log file
def getValuesFromCacheLog(logFile):

    placeId = 0 
    jobId = 0
    lastJobid = 0
    serverIp = 0
    usrId = 1
    isPrivate = False
    connected = True 

    line_position = 0 
    for line in logFile: # Go through the log file
        
        # Getting placeId
        if line.find("place") > 0:
            toReplace = find_between(line, 'place ', " at")
            if toReplace != "":
                placeId = toReplace
                line_position = logFile.index(line)
                print(logFile.index(line), type(line), line)

        # Getting jobId
        if line.find("Joining game") > 0:
            toReplace = find_between(line, "Joining game '", "'")
            if toReplace != "":
                jobId = toReplace
                line_position = logFile.index(line)
                print(logFile.index(line), type(line), line)

        # Getting serverIp
        if line.find("UDMUX") > 0:
            toReplace = find_between(line, "UDMUX server ", ",")
            if toReplace != "":
                serverIp = toReplace.split(":")
                line_position = logFile.index(line)
                print(logFile.index(line), type(line), line)

        # Getting userId
        if line.find("userid") > 0:
            toReplace = find_between(line, "userid:", ",")
            if toReplace != "":
                usrId = toReplace
                line_position = logFile.index(line)
                print(logFile.index(line), type(line), line)

        # Is it a private server
        if line.find("joinGamePostPrivateServer") > 0:
            isPrivate = True
            line_position = logFile.index(line)
            print(logFile.index(line), type(line), line)

    # Determining if the most resent message was about being Disconnected
    for line in logFile:
        if line.find("Client:Disconnect") > 0 and logFile.index(line) > line_position:
            connected = False
            print(line_position)
            print(logFile.index(line), type(line), line)
        
    return connected, placeId, jobId, lastJobid, serverIp, usrId, isPrivate

# Merge data from log and config to create RPC options
def getDataForRPC(connected, placeId, jobId, lastJobid, usrId, isPrivate, config):
    rblx_logo = "https://blog.roblox.com/wp-content/uploads/2022/08/RBLX_Logo_Launch_Wordmark.png"
    activity = {} 

    activity['pid'] = os.getpid()   # Set process ID to close RPC as soon as this script is closed

    programs = config['programs'] # Getting data of all programs in config
    robloxSettings = programs["Dyl's Roblox RPC"] # Getting data of roblox-rpc settings
    robloxRPC = robloxSettings['discord_rpc'] # Getting rpc options

    # If not connected display idle status
    if connected == False:
        activity['details'] = "Idle in Menu"
        activity['large_image'] = rblx_logo

        return activity

    # if connected display all needed info
    elif placeId and jobId:
        if lastJobid != jobId:
            universalId = urllib.request.urlopen("https://apis.roblox.com/universes/v1/places/" + placeId + "/universe")
            universalData = json.loads(universalId.read())
            theId = universalData["universeId"]

            lastJobid = jobId

            # Getting data and images
            if theId:
                print(universalData, jobId, "to", lastJobid)
                
                response = urllib.request.urlopen("https://games.roblox.com/v1/games?universeIds=" + str(theId))
                data = json.loads(response.read())

                responsePlayer = urllib.request.urlopen("https://users.roblox.com/v1/users/" + str(usrId))
                dataPlayer = json.loads(responsePlayer.read())

                responeIcon = urllib.request.urlopen("https://thumbnails.roblox.com/v1/games/icons?universeIds=" + str(theId) + "&size=512x512&format=Png&isCircular=false")
                dataIcon = json.loads(responeIcon.read())

                responePfp = urllib.request.urlopen("https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=" + str(usrId) + "&size=48x48&format=Png&isCircular=false")
                dataPfp = json.loads(responePfp.read())

                gameIcon = dataIcon["data"][0]["imageUrl"]
                pfpIcon = dataPfp["data"][0]["imageUrl"]

        # Setting up the activity  
        activity['details'] = data["data"][0]["name"]
        activity['state'] = "By " + data["data"][0]["creator"]["name"]
        activity['large_image'] = gameIcon
        activity['large_text'] = data["data"][0]["name"]
        activity['small_image'] = pfpIcon
        activity['small_text'] = dataPlayer["name"]
        activity['buttons'] = [] 
        for button_dict in robloxRPC['buttons']: # Loop used to format values in buttons' urls
            updated_dict = {}
            for k, v in button_dict.items():
                updated_dict[k] = v.format(PLACEID=placeId, JOBID=jobId)
            activity['buttons'].append(updated_dict)

        # If private display about server being private
        if isPrivate:
            activity['small_image'] = rblx_logo
            activity['small_text'] = "Protected"
            activity['state'] = "Reversed server"
        
        return activity
    
    # In all other cases display idle
    else:
        activity['details'] = "Idle in Menu"
        activity['large_image'] = rblx_logo
        
        return activity

# Workflow to go through the functions and pass the data to create RPC options
def get_activity(config):
    logFile = getCacheLog()

    connected, placeId, jobId, lastJobid, serverIp, usrId, isPrivate = getValuesFromCacheLog(logFile)
    print(getValuesFromCacheLog(logFile))

    activity = getDataForRPC(connected, placeId, jobId, lastJobid, usrId, isPrivate, config)
    print(activity)

    return activity

# Get client id from config
def getConfigSettings(config):
    if config:
    
        programs = config['programs']
        robloxSettings = programs["Dyl's Roblox RPC"]
        clientId = robloxSettings['app_id']
        print('client id success')

        return clientId
    return None

# Load config file from top level folders
def loadConfig():
    script_dir = os.path.dirname(__file__)

    rel_path = "../../config.yml"

    abs_path = os.path.join(script_dir, rel_path)

    try:
        with open(abs_path, "r") as file:
            config = yaml.safe_load(file)
        print('success config')
        return config
        
    except Exception as error:
        color_print(
            [ 
                ('Red',"["), ('',"Error"),('Red',"]"),
                ('',f" occured while loading "), 
                ('Blue', f"Config file"), 
                ('',f"\n{type(error), error}") 
            ] 
        )
    return None

# Main workflow
def main():
    config = loadConfig()
    clientId = getConfigSettings(config)
    while check_roblox_focus() and clientId:
            
            activity = get_activity(config)
            print(activity)
            
            print("Starting Client")
            print("Waiting for Discord network...")

            RPC = Presence(clientId)
            RPC.connect()
            print("Connected to Discord network!")

            start_time = time.time()
            activity['start'] = start_time   # Set time of focused activity from the point of connection

            while True:
                check_roblox_focus()

                newActivity = get_activity(config)
                newActivity['start'] = start_time
                if activity != newActivity:
                    print(newActivity)
                    RPC.clear()  # Clear the presence
                    RPC.close()  # Close the RPC connection
                    break

                RPC.update(**activity)
            
                time.sleep(15)
    
if __name__ == "__main__":
        try:
            main()
        except Exception as error:
             color_print([('Red',f'{type(error), error}')])


--- .\presets\valorant\build.bat ---

@echo off

:: BatchGotAdmin
:-------------------------------------
REM  --> Check for permissions
    IF "%PROCESSOR_ARCHITECTURE%" EQU "amd64" (
>nul 2>&1 "%SYSTEMROOT%\SysWOW64\cacls.exe" "%SYSTEMROOT%\SysWOW64\config\system"
) ELSE (
>nul 2>&1 "%SYSTEMROOT%\system32\cacls.exe" "%SYSTEMROOT%\system32\config\system"
)

REM --> If error flag set, we do not have admin.
if '%errorlevel%' NEQ '0' (
    echo Requesting administrative privileges...
    goto UACPrompt
) else ( goto gotAdmin )

:UACPrompt
    echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
    set params= %*
    echo UAC.ShellExecute "cmd.exe", "/c ""%~s0"" %params:"=""%", "", "runas", 1 >> "%temp%\getadmin.vbs"

    "%temp%\getadmin.vbs"
    del "%temp%\getadmin.vbs"
    exit /B

:gotAdmin
    pushd "%CD%"
    CD /D "%~dp0"
:--------------------------------------    
	"C:/Program Files/Python39/python.exe" -m pipreqs.pipreqs --force --no-pin
    "C:/Program Files/Python37/python.exe" -m pip install -r requirements.txt
    "C:/Program Files/Python37/python.exe" -m pip install -r requirements.txt --upgrade
    "C:/Program Files/Python37/python.exe" -m PyInstaller main.py --name="valorant-rpc" --icon=favicon.ico --hidden-import "pystray._win32" --onefile --version-file "version.py"
    pause



--- .\presets\valorant\main.py ---

from InquirerPy.utils import color_print
import ctypes,os,traceback

from src.startup import Startup 
from src.utilities.config.app_config import default_config
from src.localization.localization import Localizer

kernel32 = ctypes.WinDLL('kernel32')
user32 = ctypes.WinDLL('user32')
hWnd = kernel32.GetConsoleWindow()

if __name__ == "__main__":
    #color_print([("Tomato",f""" _   _____   __   ____  ___  ___   _  ________                
#| | / / _ | / /  / __ \/ _ \/ _ | / |/ /_  __/__________  ____
#| |/ / __ |/ /__/ /_/ / , _/ __ |/    / / / /___/ __/ _ \/ __/
#|___/_/ |_/____/\____/_/|_/_/ |_/_/|_/ /_/     /_/ / .__/\__/ 
#                                                  /_/ """),("White",f"{default_config['version']}\n")])
    try:
        app = Startup()
    except:
        user32.ShowWindow(hWnd, 1)
        kernel32.SetConsoleMode(kernel32.GetStdHandle(-10), (0x4|0x80|0x20|0x2|0x10|0x1|0x40|0x100))
        color_print([("Red bold",Localizer.get_localized_text("prints","errors","error_message"))])
        traceback.print_exc()
        input(Localizer.get_localized_text("prints","errors","exit"))
        os._exit(1)

--- .\presets\valorant\requirements.txt ---

urllib3
iso8601
Flask_Cors
requests
pypresence
valclient
pystray
pyperclip
cursor
psutil
Flask
InquirerPy
Pillow
PyInstaller
websockets


--- .\presets\valorant\VALORANT-Win64-Shipping.py ---

import time
import os
import win32gui
import win32process
import psutil
from pypresence import Presence
import asyncio

def main():
    print("RPC connected, displaying custom RPC./n1 Minute delay before swapping RP for optimization.")
    os.system("python presets/valorant/main.py")


if __name__ == "__main__":
    main()

--- .\presets\valorant\version.py ---

VSVersionInfo(
    ffi=FixedFileInfo(
        filevers=(3, 0, 0, 0),
        prodvers=(3, 0, 0, 0),
        mask=0x3f,
        flags=0x0,
        OS=0x4,
        fileType=0x1,
        subtype=0x0,
        date=(0, 0)),
    kids=[
        StringFileInfo([StringTable(
            u'040904B0',
            [StringStruct(u'CompanyName', u'Colin Hartigan'),
             StringStruct(u'FileDescription', u'VALORANT rich presence client'),
             StringStruct(u'FileVersion', u'3.0'),
             StringStruct(u'InternalName', u'rpcclient'),
             StringStruct(u'LegalCopyright', u'Colin Hartigan'),
             StringStruct(u'OriginalFilename', u'valorant-rpc.exe'),
             StringStruct(u'ProductName', u'VALORANT-rpc'),
             StringStruct(u'ProductVersion', u'3.1.0')])]),
        VarFileInfo([VarStruct(u'Translation', [1033, 1200])])])

--- .\presets\valorant\src\startup.py ---

from InquirerPy.utils import color_print
import sys, psutil, time, cursor, valclient, ctypes, traceback, os, subprocess

from .utilities.killable_thread import Thread
from .utilities.config.app_config import Config
from .utilities.config.modify_config import Config_Editor
from .utilities.processes import Processes
from .utilities.rcs import Riot_Client_Services
from .utilities.systray import Systray
from .utilities.version_checker import Checker
from .utilities.logging import Logger
from .utilities.program_data import Program_Data

from .localization.localization import Localizer

from .presence.presence import Presence

from .webserver import server

import win32gui
import win32process
import threading

# weird console window management stuff
#kernel32 = ctypes.WinDLL('kernel32')
#user32 = ctypes.WinDLL('user32')
#hWnd = kernel32.GetConsoleWindow()
#kernel32.SetConsoleMode(kernel32.GetStdHandle(-10), (0x4|0x80|0x20|0x2|0x10|0x1|0x00|0x100)) #disable inputs to console
#kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7) #allow for ANSI sequences

class Startup:
    def __init__(self):
        if not Processes.is_program_already_running():
            cursor.show()
            Logger.create_logger()
            Program_Data.update_file_location()

            self.config = Config.fetch_config()
            if "locale" in self.config.keys():
                if self.config["locale"][0] == "":
                    config = Localizer.prompt_locale(self.config)
                    Config.modify_config(config)
                    Systray.restart()

            self.installs = Program_Data.fetch_installs()
            Localizer.set_locale(self.config)
            self.config = Config.check_config()
            Localizer.config = self.config

            #Logger.debug(self.config)
            self.client = None                

            if Localizer.get_config_value("region",0) == "": # try to autodetect region on first launch
                self.check_region() 

            #ctypes.windll.kernel32.SetConsoleTitleW(f"valorant-rpc {Localizer.get_config_value('version')}") 

            color_print([("Red", Localizer.get_localized_text("prints","startup","wait_for_rpc"))])
            try:
                self.presence = Presence(self.config)
                Startup.clear_line()
            except Exception as e:
                traceback.print_exc()
                color_print([("Cyan",f"{Localizer.get_localized_text('prints','startup','discord_not_detected')} ({e})")])
                if not Processes.are_processes_running():
                    color_print([("Red", Localizer.get_localized_text("prints","startup","starting_valorant"))])
                    self.start_game()
                    os._exit(1)

            self.run()

            self.focus_check_thread = threading.Thread(target=self.focus_check_loop, daemon=True)
            self.focus_check_thread.start()
            




    def run(self):
        self.presence.update_presence("startup")
        Checker.check_version(self.config)
        if not Processes.are_processes_running():
            color_print([("Red", Localizer.get_localized_text("prints","startup","starting_valorant"))])
            self.start_game()
        
        self.setup_client()

        self.systray = Systray(self.client, self.config)
        self.dispatch_systray()
        
        if self.client.fetch_presence() is None:
            self.wait_for_presence()

        self.check_run_cli()
        self.dispatch_presence()
        self.dispatch_webserver() 
        
        color_print([("LimeGreen", f"{Localizer.get_localized_text('prints','startup','startup_successful')}\n")])
        time.sleep(5)
        #user32.ShowWindow(hWnd, 0) #hide window

    def check_valorant_focus(self):
        def get_active_window_process_name():
            hwnd = win32gui.GetForegroundWindow()
            _, pid = win32process.GetWindowThreadProcessId(hwnd)
            for proc in psutil.process_iter(['pid', 'name']):
                if proc.info['pid'] == pid:
                    return proc.info['name']
            return None

        active_window_process = get_active_window_process_name()
        if active_window_process != "VALORANT-Win64-Shipping.exe":
            self.run_main_py()

    def focus_check_loop(self):
        while True:
            self.check_valorant_focus()
            time.sleep(60)


    def run_main_py(self):
        #subprocess.Popen([sys.executable, "main.py"])
        os._exit(1)

        self.systray_thread.join()
        self.presence_thread.stop()

        
        


    def dispatch_webserver(self):
        server.client = self.client 
        server.config = self.config
        self.webserver_thread = Thread(target=server.start,daemon=True)
        self.webserver_thread.start()
        
    def dispatch_presence(self):
        self.presence_thread = Thread(target=self.presence.init_loop,daemon=True)
        self.presence_thread.start()

    def dispatch_systray(self):
        self.systray_thread = Thread(target=self.systray.run)
        self.systray_thread.start()

    def setup_client(self):
        try:
            self.client = valclient.Client(region=Localizer.get_config_value("region",0))
            self.client.activate()
            self.presence.client = self.client
        except:
            self.check_region()

    def wait_for_presence(self):
        presence_timeout = Localizer.get_config_value("startup","presence_timeout")
        presence_timer = 0 
        print()
        while self.client.fetch_presence() is None:
            Startup.clear_line()
            color_print([("Cyan", "["),("White",f"{presence_timer}"),("Cyan", f"] {Localizer.get_localized_text('prints','startup','waiting_for_presence')}")])
            presence_timer += 1
            if presence_timer >= presence_timeout:
                self.systray.exit()
                os._exit(1)
            time.sleep(1)
        Startup.clear_line()
        Startup.clear_line()

    def start_game(self):
        path = Riot_Client_Services.get_rcs_path()
        launch_timeout = Localizer.get_config_value("startup","game_launch_timeout")
        launch_timer = 0

        psutil.subprocess.Popen([path, "--launch-product=valorant", "--launch-patchline=live"])
        print()
        while not Processes.are_processes_running():
            Startup.clear_line()
            color_print([("Cyan", "["),("White",f"{launch_timer}"),("Cyan", f"] {Localizer.get_localized_text('prints','startup','waiting_for_valorant')}")])
            launch_timer += 1
            if launch_timer >= launch_timeout:
                self.systray.exit()
                os._exit(1)
            time.sleep(1)
        Startup.clear_line()

    def check_run_cli(self):
        if Localizer.get_config_value("startup","auto_launch_skincli"):
            skincli_path = self.installs.get("valorant-skin-cli")
            if skincli_path is not None:
                subprocess.Popen(f"start {skincli_path}", shell=True)

    def check_region(self):
        color_print([("Red bold",Localizer.get_localized_text("prints","startup","autodetect_region"))])
        client = valclient.Client(region="na")
        client.activate()
        sessions = client.riotclient_session_fetch_sessions()
        for _,session in sessions.items():
            if session["productId"] == "valorant":
                launch_args = session["launchConfiguration"]["arguments"]
                for arg in launch_args:
                    if "-ares-deployment" in arg:
                        region = arg.replace("-ares-deployment=","")
                        self.config[Localizer.get_config_key("region")][0] = region
                        Config.modify_config(self.config)
                        color_print([("LimeGreen",f"{Localizer.get_localized_text('prints','startup','autodetected_region')} {Localizer.get_config_value('region',0)}")])
                        time.sleep(5)
                        Systray.restart()

    @staticmethod
    def clear_line():
        sys.stdout.write("\033[F") # move cursor up one line
        sys.stdout.write("\r\033[K")

--- .\presets\valorant\src\content\content_loader.py ---

import requests

from ..localization.localization import Localizer

class Loader:

    @staticmethod 
    def fetch(endpoint="/"):
        data = requests.get(f"https://valorant-api.com/v1{endpoint}?language=all")
        return data.json()

    @staticmethod 
    def load_all_content(client):
        content_data = {
            "agents": [],
            "maps": [],
            "modes": [],   
            "comp_tiers": [],
            "season": {},
            "queue_aliases": { #i'm so sad these have to be hardcoded but oh well :(
                "newmap": "New Map",
                "competitive": "Competitive",
                "unrated": "Unrated",
                "spikerush": "Spike Rush",
                "deathmatch": "Deathmatch",
                "ggteam": "Escalation",
                "onefa": "Replication",
                "custom": "Custom",
                "snowball": "Snowball Fight",
                "swiftplay": "Swiftplay",
                "hurm": "Team Deathmatch",
                "": "Custom",
            },
            "team_aliases": {
                "TeamOne": "Defender",
                "TeamTwo": "Attacker",
                "TeamSpectate": "Observer",
                "TeamOneCoaches": "Defender Coach",
                "TeamTwoCoaches": "Attacker Coach",
            },
            "team_image_aliases": {
                "TeamOne": "team_defender",
                "TeamTwo": "team_attacker",
                "Red": "team_defender",
                "Blue": "team_attacker",
            },
            "modes_with_icons": ["ggteam","onefa","snowball","spikerush","unrated","deathmatch","swiftplay","hurm"]
        }
        all_content = client.fetch_content()
        agents = Loader.fetch("/agents")["data"]
        maps = Loader.fetch("/maps")["data"]
        modes = Loader.fetch("/gamemodes")["data"]
        comp_tiers = Loader.fetch("/competitivetiers")["data"][-1]["tiers"]
        
        for season in all_content["Seasons"]:
            if season["IsActive"] and season["Type"] == "act":
                content_data["season"] = {
                    "competitive_uuid": season["ID"],
                    "season_uuid": season["ID"],
                    "display_name": season["Name"]
                }

        for agent in agents:
            content_data["agents"].append({
                "uuid": agent["uuid"],
                "display_name": agent["displayName"]["en-US"],
                "display_name_localized": agent["displayName"][Localizer.locale],
                "internal_name": agent["developerName"]
            })

        for game_map in maps:
            content_data["maps"].append({
                "uuid": game_map["uuid"],
                "display_name": game_map["displayName"]["en-US"],
                "display_name_localized": game_map["displayName"][Localizer.locale],
                "path": game_map["mapUrl"],
                "internal_name": game_map["mapUrl"].split("/")[-1]
            })

        for mode in modes:
            content_data["modes"].append({
                "uuid": mode["uuid"],
                "display_name": mode["displayName"]["en-US"],
                "display_name_localized": mode["displayName"][Localizer.locale],
            })

        for tier in comp_tiers:
            content_data["comp_tiers"].append({
                "display_name": tier["tierName"]["en-US"],
                "display_name_localized": tier["tierName"][Localizer.locale],
                "id": tier["tier"],
            })

        return content_data


--- .\presets\valorant\src\content\packed\backup.bat ---

@echo off
setlocal

:: Define paths
set "user_profile=%USERPROFILE%"
set "start_menu_path=%user_profile%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Discord Inc"
set "desktop_path=%user_profile%\Desktop"
set "startup_path=%user_profile%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"
set "origcut_path=%cd%\origcut"

:: Define original Discord shortcut paths
set "original_start_menu_shortcut=%origcut_path%\Discord.lnk"
set "original_desktop_shortcut=%origcut_path%\Discord.lnk"
set "original_startup_shortcut=%origcut_path%\Discord.lnk"

:: Replace shortcuts
if exist "%original_start_menu_shortcut%" (
    copy "%original_start_menu_shortcut%" "%start_menu_path%\Discord.lnk" /Y
)
if exist "%original_desktop_shortcut%" (
    copy "%original_desktop_shortcut%" "%desktop_path%\Discord.lnk" /Y
)
if exist "%original_startup_shortcut%" (
    copy "%original_startup_shortcut%" "%startup_path%\Discord.lnk" /Y
)

echo Shortcuts have been restored to their original versions.
call setup.bat
endlocal


--- .\presets\valorant\src\content\packed\compiler.py ---

import os
import shutil
import subprocess
from distutils.dir_util import copy_tree
import win32com.client
import win10toast
from win10toast import ToastNotifier

def compile_to_exe():
    # Path to the script to compile and the icon
    script_path = 'run.py'
    icon_path = os.path.join('icons', 'custom-logo2.ico')
    
    # Compile the script to an executable
    subprocess.call([
        'pyinstaller', 
        '--onefile', 
        '--windowed', 
        f'--icon={icon_path}', 
        script_path
    ])

    dist_path = os.path.join(os.getcwd(), 'dist', 'run.exe')
    target_path = os.path.join(os.getcwd(), 'run.exe')
    shutil.move(dist_path, target_path)

def delete_original_shortcuts():
    user_profile = os.environ['USERPROFILE']
    start_menu_path = os.path.join(user_profile, 'AppData', 'Roaming', 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Discord Inc')
    desktop_path = os.path.join(user_profile, 'Desktop')
    startup_path = os.path.join(user_profile, 'AppData', 'Roaming', 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')
    
    discord_shortcut_name = 'Discord.lnk'
    
    try:
        os.remove(os.path.join(start_menu_path, discord_shortcut_name))
    except FileNotFoundError:
        pass
    
    try:
        os.remove(os.path.join(desktop_path, discord_shortcut_name))
    except FileNotFoundError:
        pass
    
    try:
        os.remove(os.path.join(startup_path, discord_shortcut_name))
    except FileNotFoundError:
        pass

def create_shortcut(target, shortcut_path, description, icon, working_directory):
    shell = win32com.client.Dispatch("WScript.Shell")
    shortcut = shell.CreateShortcut(shortcut_path)
    shortcut.TargetPath = target
    shortcut.WorkingDirectory = working_directory
    shortcut.IconLocation = icon
    shortcut.Description = description
    shortcut.save()

def create_new_shortcuts():
    user_profile = os.environ['USERPROFILE']
    start_menu_path = os.path.join(user_profile, 'AppData', 'Roaming', 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Discord Inc')
    desktop_path = os.path.join(user_profile, 'Desktop')
    startup_path = os.path.join(user_profile, 'AppData', 'Roaming', 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup')
    
    if not os.path.exists(start_menu_path):
        os.makedirs(start_menu_path)

    target_path = os.path.join(os.getcwd(), 'run.exe')
    config_path = os.path.join(os.getcwd(), 'setup.yml')
    working_directory = os.path.dirname(target_path)
    
    # Copy setup.yml to the target locations
#    shutil.copy(config_path, start_menu_path)    ###Not including startup folder
#    shutil.copy(config_path, desktop_path)    ###Not including startup folder
#    shutil.copy(config_path, startup_path)    ###Not including startup folder

    # Create new shortcuts with "Start In" property
    create_shortcut(
        target=target_path,
        shortcut_path=os.path.join(start_menu_path, 'Discord.lnk'),
        description='Custom Discord Shortcut',
        icon=target_path,
        working_directory=working_directory
    )
    
    create_shortcut(
        target=target_path,
        shortcut_path=os.path.join(desktop_path, 'Discord.lnk'),
        description='Custom Discord Shortcut',
        icon=target_path,
        working_directory=working_directory
    )
    
    create_shortcut(
        target=target_path,
        shortcut_path=os.path.join(startup_path, 'Discord.lnk'),
        description='Custom Discord Shortcut',
        icon=target_path,
        working_directory=working_directory
    )

def send_notification():
    toaster = ToastNotifier()
    toaster.show_toast("🎉 Success!", "Everything is set up correctly. Cleaning up and starting modified Discord. 🚀", duration=10)

def cleaning():
    bat_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'postinstaller.bat')
    subprocess.Popen([bat_path], shell=True)

if __name__ == "__main__":
    compile_to_exe()
    delete_original_shortcuts()
    create_new_shortcuts()
    send_notification()
    cleaning()


--- .\presets\valorant\src\content\packed\config.yml ---

#Work directory
work_dir: ""

# In case if you want to use only one application
# You can specify it in default_app_id
default_app_id: ""

# If set to true 
# Only default_app_id will be used
force_default_id: false

# TEMPLATE TO ADD A PROGRAM 
# FOR YOU TO COPY
template:
  TheProgram: # Like a short program name or ID (e. steam: , SPOTIFY: , VSCode: , EpicGamesLauncher)
    name: The Program # Name that will be displayed in the console 
    enable: true # Enable/Disable detection and display of this program
    executable: Program.exe # Program Executable process that is detected when focused
    app_id: 111111111111111111 # Discord Application Id to display Rich Presence
    discord_rpc: 
      details: Very good program # First line (May serve as about info)
      state: Enjoying using Program # Second line (May serve as action in program)
      large_image: large_image # id specified in dev portal for big image
      large_text: Large Image # Description text that pop up on mouse hover
      small_image: small_image # id specified in dev portal for corner image
      small_text: Small Image # Description text that pop up on mouse hover
      # Add up to TWO buttons
      # label is button text, url is destination after button is pressed
      buttons: [ 
        { 
          label: "button1", url: "https://google.com"
        },
        {
          label: "button2", url: "https://none.com"
        }
      ]
    custom_rpc_executable_path: "your\\path\\to\\script\\TheProgramRPCScript.py" # custom_rpc_exe


# LIST OF PROGRAMS TO DISPLAY
programs:
  Discord: #program_id
    name: Discord 
    enable: true
    executable: Discord.exe 
    app_id: 1262946659701096498 
    discord_rpc: 
      state: Chillin' in Discord 
      large_image: 1
    
  EpicGamesLauncher: 
    name: Epic Games Launcher
    enable: true
    executable: EpicGamesLauncher.exe
    app_id: 1263022294993731634
    discord_rpc:
      state: Choosing a game to play
      large_image: 1

  FileExplorer:
    name: File Explorer
    enable: true
    executable: explorer.exe
    app_id: 1262972467404865596
    discord_rpc:
      state: Browsing some files
      large_image: 1

  MicrosoftEdge:
    name: Edge Browser
    enable: true
    executable: msedge.exe
    app_id: 1262929038826016768
    discord_rpc:
      state: Browsing pages
      large_image: 1

  notepad:
    name: Notepad
    enable: true
    executable: Notepad.exe
    app_id: 1262987354524749906
    discord_rpc:
      state: Taking some notes
      large_image: 1

  NZXT_CAM:
    name: NZXT CAM
    enable: true
    executable: NZXT CAM.exe
    app_id: 1262983230945235065
    discord_rpc:
      state: Setting up NZXT devices
      large_image: 1

  RiotClient:
    name: Riot Client
    enable: true
    executable: Riot Client.exe
    app_id: 1262989311628808275
    discord_rpc:
      state: Choosing a game to play
      large_image: 1

  ShareX:
    name: ShareX
    enable: true
    executable: ShareX.exe
    app_id: 1262941941130068018
    discord_rpc:
      state: Screenshoting with ShareX
      large_image: 1

  steamwebhelper:
    name: steamwebhelper
    enable: true
    executable: steamwebhelper.exe
    app_id: 1262973733472305283
    discord_rpc:
      state: Choosing a game to play
      large_image: 1

  Telegram:
    name: Telegram
    enable: true
    executable: Telegram.exe
    app_id: 1262937085635985409
    discord_rpc:
      state: Chatting in Telegram
      large_image: 1

  AyuGram:
    name: AyuGram Desktop
    enable: false
    executable: ayugram.exe
    app_id: 
    discord_rpc:
      state: Chatting in Ayugram
      large_image: 1

  VLCplayer:
    name: VLC Media Player
    enable: true
    executable: vlc.exe
    app_id: 1262981573305700352
    discord_rpc:
      state: Playing media
      large_image: 1
  
  voicemeeter8x64:
    name: voicemeeter8x64
    enable: true
    executable: voicemeeter8x64.exe
    app_id: 1262944099531755551
    discord_rpc:
      state: Setting up some sound in voicemeeter
      large_image: 1

  Clipchamp:
    name: Clipchamp
    enable: true
    executable: Clipchamp.exe
    app_id: 1266991923625984064
    discord_rpc:
      state: Editing video in Clipchamp
      large_image: 1

  cmd:
    name: cmd
    enable: true
    executable: cmd.exe
    app_id: 1267022953489498193
    discord_rpc:
      state: Debugging in CMD
      large_image: 1

  WindowsTerminal:
    name: WindowsTerminal
    enable: true
    executable: WindowsTerminal.exe
    app_id: 1267022953489498193
    discord_rpc:
      state: Debugging in Windows Terminal
      large_image: 1

  SystemSettings:
    name: SystemSettings
    enable: true
    executable: SystemSettings.exe
    app_id: 1267241964353355886
    discord_rpc:
      state: Setting up the PC
      large_image: 2 #Do not change

  Taskmgr:
    name: Taskmgr
    enable: true
    executable: Taskmgr.exe
    app_id: 1267244049451192442
    discord_rpc:
      state: Monitoring processes
      large_image: 1

  Photos:
    name: Photos
    enable: true
    executable: Photos.exe
    app_id: 1267390426239864876
    discord_rpc:
      state: Looking on sosme photos
      large_image: 1

  WsaClient:
    name: WsaClient
    enable: true
    executable: WsaClient.exe
    app_id: 1267985784644829266
    discord_rpc:
      state: Running in android emulation
      large_image: 1

  GitHubDesktop:
    name: GitHubDesktop
    enable: true
    executable: GitHubDesktop.exe
    app_id: 1267987396536827905
    discord_rpc:
      state: Choosing project to work on
      large_image: 1


  Colin's Valorant RPC:
    name: Valorant
    enable: true
    executable: VALORANT-Win64-Shipping.exe
    custom_rpc_executable_path: python presets/valorant/VALORANT-Win64-Shipping.py

  Semebody's LoL RPC:
    name: League-of-legends
    enable: true
    executable: LeagueOfLegends.exe
    custom_rpc_executable_path: subprocess.Popen(os.path.join('presets/league-of-legends/start.bat'), creationflags=subprocess.CREATE_NO_WINDOW)

  Dyl's Roblox RPC:
    name: Roblox
    enable: true
    executable: RobloxPlayerBeta.exe
    app_id: 1155101158780702830
    discord_rpc:
      buttons: [
          {
            "label": "Join server" , "url": "roblox://experiences/start?placeId={PLACEID}&gameInstanceId={JOBID}"
            }, 
          {
            "label": "View on website" ,"url": "https://www.roblox.com/games/{PLACEID}/"
            }
          ]
    custom_rpc_executable_path: python presets/roblox/RobloxPlayerBeta.py

--- .\presets\valorant\src\content\packed\postinstaller.bat ---

@echo off
setlocal

echo Current directory: %cd%
echo Starting cleanup process...

:: Terminate all Python processes
echo Terminating all Python processes...
taskkill /F /IM python.exe /T
taskkill /F /IM pythonw.exe /T
taskkill /F /IM python3.11.exe /T

ping 127.0.0.1 -n 2 > nul


if exist "compiler.py" (
    echo Found folder "compiler.py", attempting to delete...
    del /f /q "compiler.py" && echo Deleted folder "compiler.py" || echo Failed to delete folder "compiler.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "req.txt" (
    echo Found folder "req.txt", attempting to delete...
    del /f /q "req.txt" && echo Deleted folder "req.txt" || echo Failed to delete folder "req.txt"
)
ping 127.0.0.1 -n 2 > nul

if exist "run.py" (
    echo Found folder "run.py", attempting to delete...
    del /f /q "run.py" && echo Deleted folder "run.py" || echo Failed to delete folder "run.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "setup.bat" (
    echo Found folder "setup.bat", attempting to delete...
    del /f /q "setup.bat" && echo Deleted folder "setup.bat" || echo Failed to delete folder "setup.bat"
)
ping 127.0.0.1 -n 2 > nul

cd lib
call RPC.bat

--- .\presets\valorant\src\content\packed\reinstaller.bat ---

@echo off
setlocal

echo Current directory: %cd%
echo Starting cleanup process...

:: Terminate all Python processes
echo Terminating all Python processes...
taskkill /F /IM python.exe /T
taskkill /F /IM pythonw.exe /T
taskkill /F /IM python3.11.exe /T

ping 127.0.0.1 -n 2 > nul

if exist "dist" (
    echo Found folder "dist", attempting to delete...
    rmdir /s /q "dist" && echo Deleted folder "dist" || echo Failed to delete folder "dist"
)
ping 127.0.0.1 -n 2 > nul

if exist "build" (
    echo Found folder "build", attempting to delete...
    rmdir /s /q "build" && echo Deleted folder "build" || echo Failed to delete folder "build"
)
ping 127.0.0.1 -n 2 > nul

if exist "presets" (
    echo Found folder "presets", attempting to delete...
    rmdir /s /q "presets" && echo Deleted folder "presets" || echo Failed to delete folder "presets"
)
ping 127.0.0.1 -n 2 > nul

if exist "icons" (
    echo Found folder "icons", attempting to delete...
    rmdir /s /q "icons" && echo Deleted folder "icons" || echo Failed to delete folder "icons"
)
ping 127.0.0.1 -n 2 > nul

if exist "venv" (
    echo Found folder "venv", attempting to delete...
    rmdir /s /q "venv" && echo Deleted folder "venv" || echo Failed to delete folder "venv"
)
ping 127.0.0.1 -n 2 > nul

if exist "BACKUP.bat" (
    echo Found file "BACKUP.bat", attempting to delete...
    del /f /q "BACKUP.bat" && echo Deleted file "BACKUP.bat" || echo Failed to delete file "BACKUP.bat"
)
ping 127.0.0.1 -n 2 > nul

if exist "config.yml" (
    echo Found file "config.yml", attempting to delete...
    del /f /q "config.yml" && echo Deleted file "config.yml" || echo Failed to delete file "config.yml"
)
ping 127.0.0.1 -n 2 > nul

if exist "main.bat" (
    echo Found file "main.bat", attempting to delete...
    del /f /q "main.bat" && echo Deleted file "main.bat" || echo Failed to delete file "main.bat"
)
ping 127.0.0.1 -n 2 > nul

if exist "README.md" (
    echo Found file "README.md", attempting to delete...
    del /f /q "README.md" && echo Deleted file "README.md" || echo Failed to delete file "README.md"
)
ping 127.0.0.1 -n 2 > nul

if exist "req.txt" (
    echo Found file "req.txt", attempting to delete...
    del /f /q "req.txt" && echo Deleted file "req.txt" || echo Failed to delete file "req.txt"
)
ping 127.0.0.1 -n 2 > nul

if exist "RPC.py" (
    echo Found file "RPC.py", attempting to delete...
    del /f /q "RPC.py" && echo Deleted file "RPC.py" || echo Failed to delete file "RPC.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "run.exe" (
    echo Found file "run.exe", attempting to delete...
    del /f /q "run.exe" && echo Deleted file "run.exe" || echo Failed to delete file "run.exe"
)
ping 127.0.0.1 -n 2 > nul

if exist "run.py" (
    echo Found file "run.py", attempting to delete...
    del /f /q "run.py" && echo Deleted file "run.py" || echo Failed to delete file "run.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "run.spec" (
    echo Found file "run.spec", attempting to delete...
    del /f /q "run.spec" && echo Deleted file "run.spec" || echo Failed to delete file "run.spec"
)
ping 127.0.0.1 -n 2 > nul

if exist "setup-step2.py" (
    echo Found file "setup-step2.py", attempting to delete...
    del /f /q "setup-step2.py" && echo Deleted file "setup-step2.py" || echo Failed to delete file "setup-step2.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "setup.bat" (
    echo Found file "setup.bat", attempting to delete...
    del /f /q "setup.bat" && echo Deleted file "setup.bat" || echo Failed to delete file "setup.bat"
)
ping 127.0.0.1 -n 2 > nul

if exist "setup.yml" (
    echo Found file "setup.yml", attempting to delete...
    del /f /q "setup.yml" && echo Deleted file "setup.yml" || echo Failed to delete file "setup.yml"
)
ping 127.0.0.1 -n 2 > nul

if exist "version.yml" (
    echo Found file "setup.yml", attempting to delete...
    del /f /q "version.yml" && echo Deleted file "version.yml" || echo Failed to delete file "version.yml"
)
ping 127.0.0.1 -n 2 > nul

if exist "main-start.bat" (
    echo Found file "main-start.bat", attempting to delete...
    del /f /q "main-start.bat" && echo Deleted file "main-start.bat" || echo Failed to delete file "main-start.bat"
)
ping 127.0.0.1 -n 2 > nul

if exist "Update-checker.py" (
    echo Found file "Update-checker.py", attempting to delete...
    del /f /q "Update-checker.py" && echo Deleted file "Update-checker.py" || echo Failed to delete file "Update-checker.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "compiler.py" (
    echo Found file "compiler.py", attempting to delete...
    del /f /q "compiler.py" && echo Deleted file "compiler.py" || echo Failed to delete file "compiler.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "defender.py" (
    echo Found file "defender.py", attempting to delete...
    del /f /q "defender.py" && echo Deleted file "defender.py" || echo Failed to delete file "defender.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "setup.py" (
    echo Found file "setup.py", attempting to delete...
    del /f /q "setup.py" && echo Deleted file "setup.py" || echo Failed to delete file "setup.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "updater.py" (
    echo Found file "updater.py", attempting to delete...
    del /f /q "updater.py" && echo Deleted file "updater.py" || echo Failed to delete file "updater.py"
)
ping 127.0.0.1 -n 2 > nul

if exist "updater.bat" (
    echo Found file "updater.bat", attempting to delete...
    del /f /q "updater.bat" && echo Deleted file "updater.bat" || echo Failed to delete file "updater.bat"
)
ping 127.0.0.1 -n 2 > nul

if exist "RPC.bat" (
    echo Found file "RPC.bat", attempting to delete...
    del /f /q "RPC.bat" && echo Deleted file "RPC.bat" || echo Failed to delete file "RPC.bat"
)
ping 127.0.0.1 -n 2 > nul

if exist "lib" (
    echo Found folder "lib", attempting to delete...
    rmdir /s /q "lib" && echo Deleted folder "lib" || echo Failed to delete folder "lib"
)
ping 127.0.0.1 -n 2 > nul



:: Check and remove shortcut
set "desktop=%USERPROFILE%\Desktop"
set "shortcut=REINSTALL-UPDATE - Shortcut.url"

if exist "%desktop%\%shortcut%" (
    echo Found shortcut "%shortcut%", attempting to delete...
    del /f /q "%desktop%\%shortcut%" && echo Deleted shortcut "%shortcut%" || echo Failed to delete shortcut "%shortcut%"
) else (
    echo No shortcut "%shortcut%" found, continuing...
)

ping 127.0.0.1 -n 2 > nul

echo Cloning repository from GitHub...
git clone https://github.com/Purple-Palm/Universal-Discord-Rich-Presence.git
cd Universal-Discord-Rich-Presence

echo Moving files to parent directory...
for /f "delims=" %%i in ('dir /b /a') do move "%%i" ..

cd ..
rmdir /s /q Universal-Discord-Rich-Presence

echo Running install.exe...
start "" "install.exe"

echo Update/Reinstall process completed.
pause


--- .\presets\valorant\src\content\packed\run.py ---

import os
import time
import subprocess
import yaml
from InquirerPy.utils import color_print


def open_discord():
    discord_path = os.path.join(os.getenv('LOCALAPPDATA'), 'Discord', 'Update.exe')
    subprocess.Popen([discord_path, '--processStart', 'Discord.exe'], shell=True)

def is_discord_open():
    try:
        output = subprocess.check_output(["tasklist"], creationflags=subprocess.CREATE_NO_WINDOW, text=True)
        return "Discord.exe" in output
    except subprocess.CalledProcessError:
        return False

def read_config():
    with open("setup.yml", 'r') as stream:
        config = yaml.safe_load(stream)
    print(f"Config work_dir: {config['work_dir']}")
    return config['work_dir']

def main():
    if not is_discord_open():
        color_print(
            [
                ('Skyblue', "Discord"),
                ('Red', " is not "),
                ('', 'open!'),
            ]
        )
        open_discord()
        time.sleep(10)  # Give Discord some time to open
        if not is_discord_open():
            color_print(
                [
                    ('Red', "Failed"),
                    ('', "to open "),
                    ('Skyblue', "Discord"), ('', '. '),
                    ('Red', "Stopping script"), ('', '. ')
                ]
            )
            return
    color_print(
        [
            ('Blue', "Discord"),
            ('Green', ' is open! '),
            ('Green', "Starting"), ('', ' RPC script.')
        ]
    )
    work_dir = read_config()
    updater_path = os.path.join(work_dir, "updater.bat")
    RPC_path = os.path.join(work_dir, "RPC.bat")
    print(f"Running {updater_path}...")
    subprocess.Popen([updater_path], shell=True)
    print("Updater started. Exiting run.py.")

    #print(f"Running {RPC_path}...")
    #subprocess.Popen([RPC_path], shell=True)
    #print("RPC started. Exiting run.py.")
    
if __name__ == "__main__":
    print("By Cactus and VGSS_")
    main()



--- .\presets\valorant\src\content\packed\setup.bat ---

@echo off
del unpack.bat
echo Setting things up...

echo Version: 7.0.0 > version.yml

:: Check for Python installation
python --version >nul 2>&1
if %errorlevel% neq 0 (
    echo No Python found, terminating
    timeout /t 5
    exit /b
)

:: Create a virtual environment
python -m venv venv

:: Activate the virtual environment
call venv\Scripts\activate.bat

:: Install required packages
pip install -r req.txt

:: Write the current working directory to setup.yml
setlocal enabledelayedexpansion
set "escaped_cd=%cd:\=\\%"
echo work_dir: "!escaped_cd!" > setup.yml

:: Create origcut folder
set "origcut_path=%cd%\origcut"
if not exist "%origcut_path%" (
    mkdir "%origcut_path%"
)

:: Find and copy the original Discord shortcut to origcut
set "user_profile=%USERPROFILE%"
set "start_menu_path=%user_profile%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Discord Inc"
set "discord_shortcut_name=Discord.lnk"

if exist "%start_menu_path%\%discord_shortcut_name%" (
    copy "%start_menu_path%\%discord_shortcut_name%" "%origcut_path%\%discord_shortcut_name%" /Y
)

:: Run the add_to_defender.py script to add the working directory to Windows Defender exclusions
powershell -Command "Start-Process python -ArgumentList 'defender.py' -Verb RunAs"

:: Run the compiler
powershell -Command "python compiler.py"




endlocal


--- .\presets\valorant\src\content\packed\updater.bat ---

@echo off
echo Starting main.bat...
taskkill /F /IM python.exe /T
taskkill /F /IM pythonw.exe /T
taskkill /F /IM python3.11.exe /T
echo Current working directory: %cd%
cd venv\Scripts
call activate.bat
cd ..\..
cd lib
python updater.py

pause



--- .\presets\valorant\src\content\packed\lib\defender.py ---

import subprocess
import os

def add_to_defender_exclusions(path):
    command = f'powershell -Command "Add-MpPreference -ExclusionPath \'{path}\'"'
    result = subprocess.run(command, shell=True, capture_output=True, text=True)
    
    if result.returncode != 0:
        print(f"Failed to add to Defender exclusions: {result.stderr}")
    else:
        print(f"Successfully added {path} to Defender exclusions.")



if __name__ == "__main__":
    current_directory = os.getcwd()
    add_to_defender_exclusions(current_directory)



--- .\presets\valorant\src\content\packed\lib\RPC.bat ---

@echo off
echo Starting main.bat...
::taskkill /F /IM python.exe /T
::taskkill /F /IM pythonw.exe /T
::taskkill /F /IM python3.11.exe /T
echo Current working directory: %cd%
cd ..
cd venv\Scripts
call activate.bat
cd ..\..
cd lib
python RPC.py

pause



--- .\presets\valorant\src\content\packed\lib\RPC.py ---

import time
import os
import win32gui
import win32process
import psutil
import yaml
from pypresence import Presence
import asyncio
from InquirerPy.utils import color_print


# Detect active window
def get_active_window_executable():
    window = win32gui.GetForegroundWindow()
    _, pid = win32process.GetWindowThreadProcessId(window)

    try:
        process = psutil.Process(pid)
        return process.name()
    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess, Exception):
        return None


# Find matching executable call in config
def get_matching_rpc_id(active_executable):
    global config
    
    is_present = False

    for prog in config['programs']:

        program = config['programs'][prog]

        if active_executable and program['executable'] == active_executable:
            is_present = True
            return is_present, prog

    color_print(
        [
            ('Skyblue',f"{active_executable}"),
            ('Yellow'," was not found"),
            (''," in the config. Nothing to display.")
        ]
    )
    return is_present, prog


# Retrieve RPC conmponents to display
def get_config_status_data(present, program_id):
    global config
    # print("[get_config_status_data]")
    # print("program_id:", program_id)
    if present and program_id:
        # try:

            # Get value of the force_default_id flag 
            force_default_id = config['force_default_id']
            # print("force_default_id:", force_default_id)

            # Set current program to received confing program_id
            program = config['programs'][program_id] 
            # print("program:", program)

            custom_rpc_exe = program.get('custom_rpc_executable_path', None)
            # print("custom_rpc_exe", custom_rpc_exe)

            enabled = program['enable']
            # print("enabled:", enabled)

            name = program['name']
            # print("name:", name)
            
            if custom_rpc_exe == None:

                # Assign defaul_app_id if flag set to true or app_id is not specified
                app_id = config['default_app_id'] if force_default_id or program['app_id'] == "" else program['app_id'] 
                # print("app_id:", app_id)

                # Pull all activity data for RPC from discord_rpc into a dictionary
                activity = {key: str(value) if type(value) is not list else value for key, value in program['discord_rpc'].items()}
                # print("activity:", activity)

            else: 
                app_id = None; activity = None
                
            return enabled, name, app_id, activity, custom_rpc_exe
        
        # except (FileNotFoundError, KeyError, ValueError, Exception) as error:
        #     print("ERROR DURING get_config_status_data: ", type(error), error)
    return False, None, None, None, None
    
# MAIN WORKFLOW
def main():
    
    # GET ALL NEEDED DATA FOR RPC
    active_executable = get_active_window_executable()
    color_print([('Green', f"Active executable changed to: "),('Skyblue', active_executable)])   # Display currently active executable in the console

    is_present, program_rpc_id = get_matching_rpc_id(active_executable)
    enabled, program_name, app_id, activity, custom_rpc_exe = get_config_status_data(is_present, program_rpc_id)

    while get_active_window_executable() == active_executable:
        if enabled and custom_rpc_exe == None:
            client_id = app_id
            RPC = Presence(client_id)
            color_print([('Green', f"RPC executable of "),('Skyblue',f"{program_name}"),('Green'," is specified.\nEstablishing  RPC connection...")])
            RPC.connect()
            color_print([('Green', f"RPC connected, displaying "),('Skyblue', program_name)])

            activity['start'] = time.time()    # Set time of focused activity from the point of connection
            
            activity['pid'] = os.getpid()   # Set process ID to close RPC as soon as this script is closed

            while True:
                if get_active_window_executable() != active_executable:
                    color_print([('Skyblue',f"{program_name}"),(''," is no longer in focus. Closing RPC connection.")])
                    RPC.clear()  # Clear the presence
                    RPC.close()  # Close the RPC connection
                    break

                RPC.update(**activity)  # Update RPC

                time.sleep(15)  # Update every 15 seconds
        
        elif enabled and custom_rpc_exe:
            color_print(
                [
                    ('Green',"Custom RPC executable of "), 
                    ('Skyblue', f"{program_name}"),
                    ('Green'," is specified.\nEstablishing  RPC connection..."),
                ] 
            )
            
            try:
                os.system(custom_rpc_exe)
            except Exception as error:
                color_print(
                    [ 
                        ('Red',"["), ('',"Error"),('Red',"]"),
                        (''," occured while running a "), 
                        ('Blue', "'custom_rpc_executable_path'"),
                        (''," of "),
                        ('Blue', f"'{program_rpc_id}'"),
                        ('',f"\n{type(error), error}") 
                    ] 
                )
                
    time.sleep(1)

# LOADING DATA FROM CONFIG 
try:
    config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'config.yml')
    with open(config_path, "r") as file:
        config = yaml.safe_load(file)
except Exception as error:
    color_print(
        [ 
            ('Red',"["), ('',"Error"),('Red',"]"),
            ('',f" occured while loading "), 
            ('Blue', f"Config file"), 
            ('',f"\n{type(error), error}") 
        ] 
    )


    

# KEEP RUNNING SCRIPT SEQUENCE
while True:
    if __name__ == "__main__":
        try:
            main()
        except Exception as error:
             color_print([('Red',f'{type(error), error}')])
             break

        

--- .\presets\valorant\src\content\packed\lib\updater.py ---

import os
import requests
import yaml
import shutil
import ctypes
from win10toast import ToastNotifier
import subprocess

def check_for_updates():
    # Define paths
    working_dir = os.path.dirname(os.path.realpath(__file__))
    parent_dir = os.path.abspath(os.path.join(working_dir, '..'))
    version_file_path = os.path.join(parent_dir, 'version.yml')
    desktop_path = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop')
    bat_file_path = os.path.join(parent_dir, 'reinstaller.bat')

    # Load the local version
    with open(version_file_path, 'r') as version_file:
        local_version = str(yaml.safe_load(version_file)['Version']).strip()

    # Fetch the GitHub README.md
    url = "https://raw.githubusercontent.com/Purple-Palm/Universal-Discord-Rich-Presence/main/README.md"
    response = requests.get(url)
    github_readme = response.text

    # Extract the version from the README.md
    version_prefix = "Version: "
    github_version = None

    for line in github_readme.split('\n'):
        if line.startswith(version_prefix):
            github_version = line.split(version_prefix)[-1].strip()
            break

    if github_version is None:
        raise ValueError("Version information not found in README.md")

    # Debug: Print versions
    print(f"Local version: '{local_version}'")
    print(f"GitHub version: '{github_version}'")

    # Initialize toaster
    toaster = ToastNotifier()

    # Compare versions
    if local_version != github_version:
        # Debug: Version mismatch
        print("Versions do not match. Update found. 🔄")

        # Send notification for update
        toaster.show_toast(f"🔄 {github_version} Update Found", f"An update for the RPC is available. You are on V{local_version}. Updating...", icon_path="icons/custom-logo2.ico", duration=10)

        # Run the batch file directly
        subprocess.Popen(bat_file_path, creationflags=subprocess.CREATE_NO_WINDOW)

        # Terminate the script
        exit()
    else:
        # Debug: Version match
        print("Versions match. No update found. ✅")

        # Send notification for no update
        toaster.show_toast("✅ No Update Found", "RPC script is up-to-date.", duration=10)

    # If no update, run main.bat in the background
    main_bat_path = os.path.join('RPC.bat')
    subprocess.Popen(main_bat_path, creationflags=subprocess.CREATE_NO_WINDOW)

if __name__ == "__main__":
    check_for_updates()


--- .\presets\valorant\src\localization\locales.py ---

Locales = {
    "en-US": {
        "author": "@.semicolin",
        "config": {
            "version": "version",
            "region": "region",
            "client_id": "client_id",
            "presence_refresh_interval": "presence_refresh_interval",
            "locale": "locale",
            "presences": "presences",
            "menu": "menu",
            "show_rank_in_comp_lobby": "show_rank_in_comp_lobby",
            "modes": "modes",
            "all": "all",
            "small_image": "small_image",
            "large_image": "large_image",
            "range": "range",
            "show_rank_in_range": "show_rank_in_range",
            "startup": "startup",
            "game_launch_timeout": "game_launch_timeout",
            "presence_timeout": "presence_timeout",
            "show_github_link": "show_github_link",
            "auto_launch_skincli": "auto_launch_skincli",
            "agent": "agent",
            "rank": "rank",
            "map": "map",
        },
        "prints": {
            "config_modification": {
                "select_option": "select a configuration option",
                "config_saved": "config saved! restart the program for changes to take effect.",
                "set_prompt": "set value for"
            },
            "startup": {
                "wait_for_rpc": "waiting for rpc client",
                "discord_not_detected": "discord not detected! starting game without presence...",
                "starting_valorant": "starting VALORANT",
                "startup_successful": "program startup successful, hiding window in 5 seconds",
                "waiting_for_presence": "waiting for presence...",
                "waiting_for_valorant": "waiting for VALORANT...",
                "autodetect_region": "attempting to autodetect region",
                "autodetected_region": "autodetected region:",
            },
            "presence": {
                "presence_running": "presence running!",
            },
            "systray": {
                "hiding_window": "hiding window",
            },
            "errors": {
                "error_message": "the program encountered an error: please create an issue with the traceback below if this problem persists",
                "exit": "press enter to exit...",
            },
            "version_checker": {
                "update_available": "an update is available! download it at",
                "checker_error": "unable to check for updates!",
            }
        },
        "presences": {
            "party_states": {
                "open": "Open Party",
                "solo": "Solo",
                "in_party": "In a Party",
            },
            "client_states": {
                "away": "Away",
                "menu": "Menu",
                "custom_setup": "Custom Setup",
                "queue": "Queue",
                "pregame": "Pregame",
            },
            "team_names": {
                "TeamOne": "Defender",
                "TeamTwo": "Attacker",
                "TeamSpectate": "Observer",
                "TeamOneCoaches": "Defender Coach",
                "TeamTwoCoaches": "Attacker Coach",
            },
            "modes": {
                "newmap": "New Map",
                "competitive": "Competitive",
                "unrated": "Unrated",
                "spikerush": "Spike Rush",
                "deathmatch": "Deathmatch",
                "ggteam": "Escalation",
                "onefa": "Replication",
                "custom": "Custom",
                "snowball": "Snowball Fight",
                "swiftplay": "Swiftplay",
                "hurm": "Team Deathmatch",
                "": "Custom",
            },
            "pregame": {
                "selecting": "Selecting",
                "locked": "Locked",
            },
            "leveling": {
                "level": "Level",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "Loading",
                "view_github": "View on GitHub",
            }
        },
    },
    "ar-AE": {
        "author": "@Ozama#8188",
        "config": {
            "version": "الإصدار",
            "region": "المنطقة",
            "client_id": "client_ID",
            "presence_refresh_interval": "الفاصل_الزمني_لتحديث_الحالة",
            "locale": "locale",
            "presences": "الحالات",
            "menu": "القائمة",
            "show_rank_in_comp_lobby": "عرض_الرانك",
            "modes": "الأنماط",
            "all": "الكل",
            "small_image": "صورة_صغيرة",
            "large_image": "صورة_عريضة",
            "range": "تدريب",
            "show_rank_in_range": "عرض_الرانك_في_التدريب",
            "startup": "startup",
            "game_launch_timeout": "إنتهت_مهلة_بدأ_اللعبة",
            "presence_timeout": "إنتهت_مهلة_الحالة",
            "show_github_link": "عرض_رابط_GitHub",
            "auto_launch_skincli": "auto_launch_skincli",
            "agent": "العميل",
            "rank": "الرانك",
            "map": "الخريطة",
        },
        "prints": {
            "config_modification": {
                "select_option": "حدد خيار اللإعداد",
                "config_saved": "تم حفظ الإعدادات! أعد تشغيل البرنامج لمشاهدة التغيرات",
                "set_prompt": "عيّن قيمة"
            },
            "startup": {
                "wait_for_rpc": "يرجى إنتظار الحالة المخصصة ...",
                "discord_not_detected": "لم يتم التعرف على ديسكورد, يجري تشغيل اللعبة دون الحالة المخصصة",
                "starting_valorant": "جاري تشغيل فالورانت ...",
                "startup_successful": "تم تشغيل البرنامج, يجري إخفاء النافذة بعد 5 ثوان ...",
                "waiting_for_presence": "في إنتظار الحالة ...",
                "waiting_for_valorant": "في إنتظار فالورانت ...",
                "autodetect_region": "محاولة الكشف التلقائي عن المنطقة",
                "autodetected_region": "تم الكشف عن المنطقة :",
            },
            "presence": {
                "presence_running": "الحالة قيد التشغيل",
            },
            "systray": {
                "hiding_window": "إخفاء النافذة",
            },
            "errors": {
                "error_message": "حدث خطأ: الرجاء إنشاء خطأ على github مع التتبع الموجود أسفل هذه الرسالة إذا استمرت المشكلة.",
                "exit": "إضغط على Enter للإغلاق",
            },
            "version_checker": {
                "update_available": "تحديث متاح! قم بتنزيله من هنا:",
                "checker_error": "لا يمكن العثور على تحديث",
            }
        },
        "presences": {
            "party_states": {
                "open": "مفتوح",
                "solo": "فردي",
                "in_party": "في بارتي",
            },
            "client_states": {
                "away": "بعيد",
                "menu": "القائمة",
                "custom_setup": "مخصص",
                "queue": "طابور",
                "pregame": "البحث عن مباراة",
            },
            "team_names": {
                "TeamOne": "مدافع",
                "TeamTwo": "مهاجم",
                "TeamSpectate": "مشاهد",
                "TeamOneCoaches": "مدرب المدافعين",
                "TeamTwoCoaches": "مدرب المهاجمين",
            },
            "modes": {
                "newmap": "خريطة جديدة",
                "competitive": "تنافسي",
                "unrated": "غير مصنف",
                "spikerush": "سبايك راش",
                "deathmatch": "مبارات الموت",
                "ggteam": "تصعيد",
                "onefa": "إستنساخ",
                "custom": "مخصص",
                "snowball": "كرات الثلج",
                "": "خاص",
            },
            "pregame": {
                "selecting": "إختيار عميل",
                "locked": "مغلق",
            },
            "leveling": {
                "level": "المستوى",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "تحميل",
                "view_github": "إنتقل إلى GitHub",
            }
        },
    },
    "de-DE": {
        "author": "@zaykenyon, @craftpiwurzel#8368, @Aethese#1337",
        "config": {
            "version": "version",
            "region": "region",
            "client_id": "client_ID",
            "presence_refresh_interval": "statusaktualisierungsintervall",
            "locale": "locale",
            "presences": "status",
            "menu": "menü",
            "show_rank_in_comp_lobby": "zeige_rang_in_comp_lobby",
            "modes": "modi",
            "all": "alle",
            "small_image": "kleines_Bild",
            "large_image": "großes_Bild",
            "range": "trainingslager",
            "show_rank_in_range": "zeige_Rang_im_Trainingslager",
            "startup": "anfang",
            "game_launch_timeout": "spiel_start_Auszeit",
            "presence_timeout": "status_Auszeit",
            "show_github_link": "zeige_Github_Link",
            "auto_launch_skincli": "starte_skincli_automatisch",
            "agent": "agent",
            "rank": "rang",
            "map": "karte",
        },
        "prints": {
            "config_modification": {
                "select_option": "Wähle eine Konfigurationsoption aus",
                "config_saved": "Konfiguration gespeichert! Starte das Programm neu um die Änderungen zu sehen",
                "set_prompt": "Setze den Wert für"
            },
            "startup": {
                "wait_for_rpc": "Warte auf rpc Client",
                "discord_not_detected": "Discord nicht erkannt! Das Spiel wird ohne Präsenz gestartet...",
                "starting_valorant": "VALORANT wird gestartet...",
                "startup_successful": "Programmstart Erfolgreich, Fenster wird in 5 Sekunden versteckt",
                "waiting_for_presence": "Warte auf Präsenz...",
                "waiting_for_valorant": "Warte auf VALORANT...",
                "autodetect_region": "Es wird versucht, die Region automatisch zu ermitteln...",
                "autodetected_region": "Automatisch ermittelte Region:",
            },
            "presence": {
                "presence_running": "Status läuft",
            },
            "systray": {
                "hiding_window": "versteckt Fenster",
            },
            "errors": {
                "error_message": "Es ist ein Fehler aufgetreten: Bitte erstellen Sie einen Fehler auf github mit dem traceback unter dieser Nachricht, sollte das Problem bestehen.",
                "exit": "Drücken Sie enter zum Schließen",
            },
            "version_checker": {
                "update_available": "Es ist eine Aktualisierung verfügbar! Lade sie hier herunter:",
                "checker_error": "Es konnte keine Aktualisierung gefunden werden",
            }
        },
        "presences": {
            "party_states": {
                "open": "Offen",
                "solo": "Solo",
                "in_party": "In einer Gruppe",
            },
            "client_states": {
                "away": "Abwesend",
                "menu": "Menü",
                "custom_setup": "Custom",
                "queue": "Warteschlange",
                "pregame": "Vor dem Spiel",
            },
            "team_names": {
                "TeamOne": "Verteidiger",
                "TeamTwo": "Angreifer",
                "TeamSpectate": "Zuschauer",
                "TeamOneCoaches": "Verteidiger Trainer",
                "TeamTwoCoaches": "Angreifer Trainer",
            },
            "modes": {
                "newmap": "Neue Karte",
                "competitive": "Gewertet",
                "unrated": "Ungewertet",
                "spikerush": "Spike-Ansturm",
                "deathmatch": "Deathmatch",
                "ggteam": "Eskalation",
                "onefa": "Klonprogramm",
                "custom": "Eigenes Spiel",
                "snowball": "Schneeballschlacht",
                "swiftplay": "Schnelles Spiel",
                "": "Custom",
            },
            "pregame": {
                "selecting": "Wählt",
                "locked": "Ausgewählt",
            },
            "leveling": {
                "level": "Level",
                "ranked_rating": "RW",
            },
            "startup": {
                "loading": "Lädt",
                "view_github": "Auf GitHub ansehen",
            }
        },
    },
    "es-ES": {
        "author": "@Rubiz#0822",
        "config": {
            "version": "versión",
            "region": "región",
            "client_id": "client_id",
            "presence_refresh_interval": "intervalo_de_refresco_de_presencia",
            "locale": "idioma",
            "presences": "presencias",
            "menu": "menu",
            "show_rank_in_comp_lobby": "mostrar_rango_en_lobby_competitivo",
            "modes": "modos",
            "all": "todo",
            "small_image": "imagen_pequeña",
            "large_image": "imagen_grande",
            "range": "range",
            "show_rank_in_range": "mostrar_rango_en_range",
            "startup": "inicio",
            "game_launch_timeout": "tiempo_de_espera_para_inicio_del_juego",
            "presence_timeout": "tiempo_de_espera_para_la_presencia",
            "show_github_link": "mostrar_link_de_github",
            "auto_launch_skincli": "iniciar_skincli_automaticamente",
            "agent": "agente",
            "rank": "rango",
            "map": "mapa",
        },
        "prints": {
            "config_modification": {
                "select_option": "selecciona una opción de configuración",
                "config_saved": "configuración guardada! reinicia el programa para que los cambios tengan efecto.",
                "set_prompt": "cambiar valor de"
            },
            "startup": {
                "wait_for_rpc": "Esperando al cliente rpc",
                "discord_not_detected": "Discord no detectado! iniciando el juego sin la presencia...",
                "starting_valorant": "Iniciando VALORANT",
                "startup_successful": "El programa se ha iniciado correctamente, ocultando la ventanta en 5 segundos",
                "waiting_for_presence": "Esperando a la presencia...",
                "waiting_for_valorant": "Esperando a VALORANT...",
                "autodetect_region": "Intentando autodetectar la región",
                "autodetected_region": "Región autodetectada:",
            },
            "presence": {
                "presence_running": "Presencia funcionando!",
            },
            "systray": {
                "hiding_window": "Ocultando ventana",
            },
            "errors": {
                "error_message": "El programa ha encontrado un error: Por favor crea un issue en GitHub con el traceback de abajo si el problema persiste",
                "exit": "Pulsa Enter para salir...",
            },
            "version_checker": {
                "update_available": "Hay una actualización disponible! Descargala en",
                "checker_error": "No se pudo comprobar si hay actualizaciones!",
            }
        },
        "presences": {
            "party_states": {
                "open": "Grupo Abierto",
                "solo": "Solo",
                "in_party": "En un Grupo",
            },
            "client_states": {
                "away": "Fuera del juego",
                "menu": "Menu",
                "custom_setup": "Custom Setup",
                "queue": "Cola",
                "pregame": "Prepartida",
            },
            "team_names": {
                "TeamOne": "Defensor",
                "TeamTwo": "Atacante",
                "TeamSpectate": "Observador",
                "TeamOneCoaches": "Entrenador Defensor",
                "TeamTwoCoaches": "Entrenador Atacante",
            },
            "modes": {
                "newmap": "Nuevo Mapa",
                "competitive": "Competitivo",
                "unrated": "No Competitivo",
                "spikerush": "Fiebre de la Spike",
                "deathmatch": "Combate a Muerte",
                "ggteam": "Carrera Armamentística",
                "onefa": "Copia",
                "custom": "Custom",
                "snowball": "Pelea de Bolas de Nieve",
                "": "Personalizada",
            },
            "pregame": {
                "selecting": "Seleccionando",
                "locked": "Lockeado",
            },
            "leveling": {
                "level": "Nivel",
                "ranked_rating": "PR",
            },
            "startup": {
                "loading": "Cargando",
                "view_github": "Ver en GitHub",
            }
        },
    },
    "es-MX": {
        "author": "@pessimismo",
        "config": {  # fix any grammar mistakes you can find
            "version": "versión",
            "region": "región",
            "client_id": "client_id",
            "presence_refresh_interval": "intervalo_actualizar_presencia",
            "locale": "localidad",
            "presences": "presencias",
            "menu": "menu",
            "show_rank_in_comp_lobby": "mostrar_rango_en_grupo_competitivo",
            "modes": "modos",
            "all": "todos",
            "small_image": "imagen_pequeña",
            "large_image": "imagen_grande",
            "range": "range",
            "show_rank_in_range": "mostrar_rango_en_range",
            "startup": "arranque",
            "game_launch_timeout": "tiempo_espera_juego",
            "presence_timeout": "tiempo_espera_presencia",
            "show_github_link": "mostrar_link_github",
            "auto_launch_skincli": "auto_lanzar_skincli",
            "agent": "agente",
            "rank": "rango",
            "map": "mapa",
        },
        "prints": {
            "config_modification": {
                "select_option": "seleccione una opción de configuración",
                "config_saved": "¡configuración guardada! reiniciar el programa para que los cambios surtan efecto.",
                "set_prompt": "establecer el valor de"
            },
            "startup": {
                "wait_for_rpc": "esperando al cliente rpc",
                "discord_not_detected": "¡discord no detectada! empezando el juego sin presencia...",
                "starting_valorant": "empezando el VALORANT",
                "startup_successful": "inicio del programa con éxito, ocultando la ventana en 5 segundos",
                "waiting_for_presence": "esperando la presencia...",
                "waiting_for_valorant": "esperando lo VALORANT...",
                "autodetect_region": "intento de autodetección de la región",
                "autodetected_region": "región autodetectada:",
            },
            "presence": {
                "presence_running": "¡presencia rodando!",
            },
            "systray": {
                "hiding_window": "ocultando la ventana",
            },
            "errors": {
                "error_message": "el programa ha encontrado un error: por favor, cree una issue con el rastreo de abajo si este problema persiste",
                "exit": "pulse enter para salir...",
            },
            "version_checker": {
                "update_available": "¡hay una actualización disponible! descárguela en",
                "checker_error": "no se puede comprobar si hay actualizaciones..",
            }
        },
        "presences": {
            "party_states": {
                "open": "Grupo Abierto",
                "solo": "Solo",
                "in_party": "En un Grupo",
            },
            "client_states": {
                "away": "Fuera",
                "menu": "Menu",
                "custom_setup": "Personalizada",
                "queue": "En Cola",
                "pregame": "Pre-Juego",
            },
            "team_names": {
                "TeamOne": "Defensor",
                "TeamTwo": "Atacante",
                "TeamSpectate": "Espectador",
                "TeamOneCoaches": "Entrenador de los Defensores",
                "TeamTwoCoaches": "Entrenador de los Atacantes",
            },
            "modes": {
                "newmap": "Nuevo Mapa",
                "competitive": "Competitivo",
                "unrated": "Normal",
                "spikerush": "Spike Rush",
                "deathmatch": "Deathmatch",
                "ggteam": "Carrera de Armas",
                "onefa": "Replica",
                "custom": "Personalizada",
                "snowball": "Pelea de Bolas de Nieve",
                "": "Personalizada",
            },
            "pregame": {
                "selecting": "Seleccionando",
                "locked": "Fijado",
            },
            "leveling": {
                "level": "Nivel",
                # i set my game in spanish for most of these...
                "ranked_rating": "CC",
            },
            "startup": {
                "loading": "Cargando",
                "view_github": "Ver en GitHub",
            }
        },
    },
    "fr-FR": {
        "author": "@Hurdenn#2777",
        "config": {
            "version": "version",
            "region": "region",
            "client_id": "ID_client",
            "presence_refresh_interval": "interval_rafraichissement_présence",
            "locale": "localisation",
            "presences": "status",
            "menu": "menu",
            "show_rank_in_comp_lobby": "montrer_rang_en_partie_compétitive",
            "modes": "modes",
            "all": "tous",
            "small_image": "petite_image",
            "large_image": "grande_image",
            "range": "camp_d'entrainement",
            "show_rank_in_range": "montrer_rang_dans_le_camp_d'entrainement",
            "startup": "lancement",
            "game_launch_timeout": "délai_d'expiration_lancement_jeu",
            "presence_timeout": "délai_d'expiration_présence",
            "show_github_link": "montrer_lien_github",
            "auto_launch_skincli": "lancement_automatique_skincli",
            "agent": "agent",
            "rank": "rang",
            "map": "carte",
        },
        "prints": {
            "config_modification": {
                "select_option": "sélectinnez une option de configuration",
                "config_saved": "configuration sauvée! Relancez le programme pour que les changements prennent effets.",
                "set_prompt": "set value for"
            },
            "startup": {
                "wait_for_rpc": "en attente du client rpc",
                "discord_not_detected": "discord non détecté! lancement du jeu sans présence...",
                "starting_valorant": "lancement de VALORANT",
                "startup_successful": "lancement du programme réussi, la fenêtre sera cachée dans 5 secondes",
                "waiting_for_presence": "en attente de la présence...",
                "waiting_for_valorant": "en attente de VALORANT...",
                "autodetect_region": "tentative de détection automatique de la région",
                "autodetected_region": "région détectée automatiquement:",
            },
            "presence": {
                "presence_running": "la présence est en cours!",
            },
            "systray": {
                "hiding_window": "dissimulation de la fenêtre",
            },
            "errors": {
                "error_message": "le programme a rencontré une erreur: veuillez créer une erreur avec le retour ci-dessous si ce problème persiste",
                "exit": "appuyez sur entrer pour quitter...",
            },
            "version_checker": {
                "update_available": "une mise à jour est disponible! téléchargez-la via",
                "checker_error": "impossible de vérifier les mises à jour!",
            }
        },
        "presences": {
            "party_states": {
                "open": "Partie ouverte",
                "solo": "Seul",
                "in_party": "Dans une Partie",
            },
            "client_states": {
                "away": "Absent",
                "menu": "Menu",
                "custom_setup": "Préparation de Personalisée",
                "queue": "En recherche de partie",
                "pregame": "Pré-partie",
            },
            "team_names": {
                "TeamOne": "Défense",
                "TeamTwo": "Attaque",
                "TeamSpectate": "Observateur",
                "TeamOneCoaches": "Coach de la défense",
                "TeamTwoCoaches": "Coach de l'attaque",
            },
            "modes": {
                "newmap": "Nouvelle carte",
                "competitive": "Compétitive",
                "unrated": "Non classée",
                "spikerush": "Spike Rush",
                "deathmatch": "Match à mort",
                "ggteam": "Intensification",
                "onefa": "Réplication",
                "custom": "Partie personalisée",
                "snowball": "Bataille de boule de neige",
                "": "Pesonalisée",
            },
            "pregame": {
                "selecting": "En sélection",
                "locked": "Verrouillé",
            },
            "leveling": {
                "level": "Niveau",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "Chargement",
                "view_github": "Voir sur GitHub",
            }
        },
    },
    "id-ID": {
        "author": "@sryo#9955",
        "config": {
            "version": "versi",
            "region": "wilayah",
            "client_id": "client_id",
            "presence_refresh_interval": "presence_refresh_interval",
            "locale": "lokal",
            "presences": "presences",
            "menu": "menu",
            "show_rank_in_comp_lobby": "perlihatkan_pangkat_di_lobi_kompetitif",
            "modes": "modes",
            "all": "semua",
            "small_image": "gambar_kecil",
            "large_image": "gambar_besar",
            "range": "jangkauan",
            "show_rank_in_range": "perlihatkan_pangkat_dalam_jangkauan",
            "startup": "memulai",
            "game_launch_timeout": "waktu_habis_peluncuran_game",
            "presence_timeout": "waktu_habis_presence",
            "show_github_link": "tunjukkan_link_github",
            "auto_launch_skincli": "otomatis_membuka_skincli",
            "agent": "agen",
            "rank": "pangkat",
            "map": "peta",
        },
        "prints": {
            "config_modification": {
                "select_option": "pilih opsi konfigurasi",
                "config_saved": "konfig tersimpan! buka ulang program agar perubahan diterapkan.",
                "set_prompt": "atur nilai untuk"
            },
            "startup": {
                "wait_for_rpc": "menunggu rpc client",
                "discord_not_detected": "discord tidak terdeteksi! membuka game tanpa presence...",
                "starting_valorant": "membuka VALORANT",
                "startup_successful": "program startup berhasil, menyembunyikan jendela dalam 5 detik",
                "waiting_for_presence": "menunggu presence...",
                "waiting_for_valorant": "menunggu VALORANT...",
                "autodetect_region": "mencoba untuk otomatis mendeteksi wilayah",
                "autodetected_region": "wilayah terdeteksi:",
            },
            "presence": {
                "presence_running": "presence berjalan!",
            },
            "systray": {
                "hiding_window": "menyembunyikan jendela",
            },
            "errors": {
                "error_message": "program mengalami kesalahan: mohon membuat issue dengan traceback dibawah jika masalah ini berlanjut",
                "exit": "tekan enter untuk keluar...",
            },
            "version_checker": {
                "update_available": "pembaruan tersedia! unduh di",
                "checker_error": "tidak dapat memeriksa pembaruan!",
            }
        },
        "presences": {
            "party_states": {
                "open": "Party Terbuka",
                "solo": "Solo",
                "in_party": "Dalam Party",
            },
            "client_states": {
                "away": "Pergi",
                "menu": "Menu",
                "custom_setup": "Custom Setup",
                "queue": "Antre",
                "pregame": "Pregame",
            },
            "team_names": {
                "TeamOne": "Bertahan",
                "TeamTwo": "Penyerang",
                "TeamSpectate": "Pengamat",
                "TeamOneCoaches": "Pelatih Bertahan",
                "TeamTwoCoaches": "Pelatih Penyerang",
            },
            "modes": {
                "newmap": "Peta Baru",
                "competitive": "Kompetitif",
                "unrated": "Unrated",
                "spikerush": "Spike Rush",
                "deathmatch": "Deathmatch",
                "ggteam": "Eskalasi",
                "onefa": "Replikasi",
                "custom": "Custom",
                "snowball": "Perang Bola Salju",
                "": "Custom",
            },
            "pregame": {
                "selecting": "Memilih",
                "locked": "Terkunci",
            },
            "leveling": {
                "level": "Level",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "Memuat",
                "view_github": "Lihat di GitHub",
            }
        },
    },
    "it-IT": {
        "author": "@zaykenyon",
        "config": {
            "version": "version",
            "region": "region",
            "client_id": "client_id",
            "presence_refresh_interval": "intervallo_refresh_presence",
            "locale": "locale",
            "presences": "presences",
            "menu": "menu",
            "show_rank_in_comp_lobby": "mostra_rank_in_comp_lobby",
            "modes": "modalità",
            "all": "tutto",
            "small_image": "immagine_piccola",
            "large_image": "immagine_grande",
            "range": "range",
            "show_rank_in_range": "mostra_rank_nel_range",
            "startup": "avvio",
            "game_launch_timeout": "timeout_di_avvio",
            "presence_timeout": "presence_timeout",
            "show_github_link": "mostra_link_github",
            "auto_launch_skincli": "avvio_automatico_skincli",
            "agent": "agente",
            "rank": "rank",
            "map": "mappa",
        },
        "prints": {
            "config_modification": {
                "select_option": "seleziona una opzione di configurazione",
                "config_saved": "configurazione salvata! Riavvia il programma per rendere effettive le modifiche.",
                "set_prompt": "imposta valore a"
            },
            "startup": {
                "wait_for_rpc": "aspettando il client rpc",
                "discord_not_detected": "discord non rilevato! avviando il gioco senza presence...",
                "starting_valorant": "avviando VALORANT",
                "startup_successful": "avvio del programma avvenuto con successo, nascondendo la finestra in 5 secondi...",
                "waiting_for_presence": "aspettando presence...",
                "waiting_for_valorant": "aspettando VALORANT...",
                "autodetect_region": "tentando di rilevare automaticamente la regione",
                "autodetected_region": "regione rilevata:",
            },
            "presence": {
                "presence_running": "presence in funzione!",
            },
            "systray": {
                "hiding_window": "nascondendo la finestra..",
            },
            "errors": {
                "error_message": "il programma ha incontrato un errore: per favore facci sapere il traceback qua sotto.",
                "exit": "premi invio per uscire...",
            },
            "version_checker": {
                "update_available": "un aggiornamento è disponibile! Scaricalo qui:",
                "checker_error": "impossibile verificare la disponibilità di aggiornamenti!",
            }
        },
        "presences": {
            "party_states": {
                "open": "Party Aperto",
                "solo": "Singolo",
                "in_party": "In un party",
            },
            "client_states": {
                "away": "AFK",
                "menu": "Menu",
                "custom_setup": "Custom Setup",
                "queue": "Coda",
                "pregame": "Pregame",
            },
            "team_names": {
                "TeamOne": "Difensori",
                "TeamTwo": "Attaccanti",
                "TeamSpectate": "Osservatore",
                "TeamOneCoaches": "Coach Difensori",
                "TeamTwoCoaches": "Coach Attaccanti",
            },
            "modes": {
                "newmap": "Nuova Mappa",
                "competitive": "Competitive",
                "unrated": "Unrated",
                "spikerush": "Spike Rush",
                "deathmatch": "Deathmatch",
                "ggteam": "Escalation",
                "onefa": "Replication",
                "custom": "Custom",
                "snowball": "Snowball Fight",
                "": "Custom",
            },
            "pregame": {
                "selecting": "Selezionando",
                "locked": "Selezionato",
            },
            "leveling": {
                "level": "Livello",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "Caricamento",
                "view_github": "Vedi su GitHub",
            }
        },
    },
    "ja-JP": {
        "author": "@Yossi#1114",
        "config": {
            "version": "バージョン",
            "region": "地域",
            "client_id": "client_id",
            "presence_refresh_interval": "presence_refresh_interval",
            "locale": "locale",
            "presences": "ステータス",
            "menu": "メニュー",
            "show_rank_in_comp_lobby": "show_rank_in_comp_lobby",
            "modes": "モード",
            "all": "全て",
            "small_image": "small_image",
            "large_image": "large_image",
            "range": "射撃場",
            "show_rank_in_range": "show_rank_in_range",
            "startup": "スタートアップ",
            "game_launch_timeout": "game_launch_timeout",
            "presence_timeout": "presence_timeout",
            "show_github_link": "show_github_link",
            "auto_launch_skincli": "auto_launch_skincli",
            "agent": "エージェント",
            "rank": "ランク",
            "map": "マップ",
        },
        "prints": {
            "config_modification": {
                "select_option": "設定を選択する",
                "config_saved": "設定を保存しました！ プログラムを再起動して設定を有効化してください。",
                "set_prompt": "値を設定:"
            },
            "startup": {
                "wait_for_rpc": "rpcクライアントを待機中",
                "discord_not_detected": "Discordの起動が確認できませんでした。ステータスの表示なしでゲームを起動します。",
                "starting_valorant": "VALORANTを起動中",
                "startup_successful": "プログラムの起動が完了、 ウィンドウを5秒以内に閉じます...",
                "waiting_for_presence": "ステータスを待機中...",
                "waiting_for_valorant": "VALORANTを待機中...",
                "autodetect_region": "地域の自動検出を試みています...",
                "autodetected_region": "自動検出された地域:",
            },
            "presence": {
                "presence_running": "ステータス表示中！",
            },
            "systray": {
                "hiding_window": "ウィンドウを閉じる",
            },
            "errors": {
                "error_message": "プログラムがエラーを検出: 問題が続く場合は以下の記録とともにissueを作成してください。",
                "exit": "Enterを押して閉じる...",
            },
            "version_checker": {
                "update_available": "アップデートが利用可能です！ こちらでダウンロードしてください:",
                "checker_error": "アップデートを確認できませんでした。",
            }
        },
        "presences": {
            "party_states": {
                "open": "オープンパーティー",
                "solo": "ソロ",
                "in_party": "パーティーに参加中",
            },
            "client_states": {
                "away": "離席中",
                "menu": "メニュー",
                "custom_setup": "カスタム設定",
                "queue": "マッチを検索中",
                "pregame": "試合開始前",
            },
            "team_names": {
                "TeamOne": "ディフェンダー",
                "TeamTwo": "アタッカー",
                "TeamSpectate": "観戦者",
                "TeamOneCoaches": "ディフェンダー側コーチ",
                "TeamTwoCoaches": "アタッカー側コーチ",
            },
            "modes": {
                "newmap": "新マップ",
                "competitive": "コンペティティブ",
                "unrated": "アンレート",
                "spikerush": "スパイクラッシュ",
                "deathmatch": "デスマッチ",
                "ggteam": "エスカレーション",
                "onefa": "レプリケーション",
                "custom": "カスタムゲーム",
                "snowball": "スノーボールファイト",
                "swiftplay": "スイフトプレイ",
                "hurm": "チームデスマッチ",
                "": "カスタム",
            },
            "pregame": {
                "selecting": "選択中",
                "locked": "ロック済み",
            },
            "leveling": {
                "level": "レベル",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "ロード中",
                "view_github": "GitHubで確認",
            }
        },
    },
    "ko-KR": {
        "author": "@페이즈#5384, @인간#6609",
        "config": {
            "version": "버전",
            "region": "지역",
            "client_id": "클라이언트 아이디",
            "presence_refresh_interval": "활동 상태 재표시 간격 타이밍",
            "locale": "장소",
            "presences": "활동 상태",
            "menu": "메뉴",
            "show_rank_in_comp_lobby": "경쟁 로비에 티어 표시",
            "modes": "모드",
            "all": "전체",
            "small_image": "작은 사진",
            "large_image": "큰 사진",
            "range": "훈련장",
            "show_rank_in_range": "훈련장에서 티어 표시",
            "startup": "시작",
            "game_launch_timeout": "게임 시작 시간초과",
            "presence_timeout": "활동 상태 시간초과",
            "show_github_link": "github 링크 표시",
            "auto_launch_skincli": "스킨 클라이언트 자동 실행",
            "agent": "요원",
            "rank": "랭크",
            "map": "맵",
        },
        "prints": {
            "config_modification": {
                "select_option": "설정 선택",
                "config_saved": "설정이 저장되었습니다! 변경 사항을 적용하기위해 프로그램을 다시 시작하세요.",
                "set_prompt": "에 대한 값을 설정"
            },
            "startup": {
                "wait_for_rpc": "rpc 클라이언트 기다리는중",
                "discord_not_detected": "디스코드가 감지되지 않았습니다! 활동 상태 없이 게임을 시작합니다...",
                "starting_valorant": "VALORANT를 시작하는중",
                "startup_successful": "프로그램을 실행에 성공했습니다, 5초뒤에 창을 숨깁니다.",
                "waiting_for_presence": "활동 상태 기다리는중...",
                "waiting_for_valorant": "VALORANT 기다리는중...",
                "autodetect_region": "지역 자동 감지를 시도하는중",
                "autodetected_region": "자동 감지된 지역:",
            },
            "presence": {
                "presence_running": "활동 상태를 표시중입니다!",
            },
            "systray": {
                "hiding_window": "창 숨기기",
            },
            "errors": {
                "error_message": "프로그램에 오류가 발생했습니다! 문제가 계속되면 아래 기록과 함께 issue를 만들어주세요.",
                "exit": "종료하려면 Enter를 누르십시오...",
            },
            "version_checker": {
                "update_available": "업데이트가 있습니다! 여기에서 다운로드 하세요",
                "checker_error": "업데이트를 확인할 수 없습니다!",
            }
        },
        "presences": {
            "party_states": {
                "open": "공개 파티",
                "solo": "솔로",
                "in_party": "파티 참가중",
            },
            "client_states": {
                "away": "자리 비움",
                "menu": "메뉴",
                "custom_setup": "사용자 정의 설정",
                "queue": "매칭중",
                "pregame": "요원 선택",
            },
            "team_names": {
                "TeamOne": "수비팀",
                "TeamTwo": "공격팀",
                "TeamSpectate": "관전자",
                "TeamOneCoaches": "수비팀 코치",
                "TeamTwoCoaches": "공격팀 코치",
            },
            "modes": {
                "newmap": "신규맵",
                "competitive": "경쟁전",
                "unrated": "일반전",
                "spikerush": "스파이크 돌격",
                "deathmatch": "데스매치",
                "ggteam": "에스컬레이션",
                "onefa": "복제",
                "custom": "사용자 설정 게임",
                "snowball": "눈싸움",
                "": "커스텀",
            },
            "pregame": {
                "selecting": "선택중",
                "locked": "선택됨",
            },
            "leveling": {
                "level": "레벨",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "로딩중",
                "view_github": "GitHub 보기",
            }
        },
    },
    "pl-PL": {},
    "pt-BR": {
        "author": "@pessimismo",
        "config": {
            "version": "versão",
            "region": "região",
            "client_id": "client_id",
            "presence_refresh_interval": "intervalo_atualização_presença",
            "locale": "localidade",
            "presences": "presenças",
            "menu": "menu",
            "show_rank_in_comp_lobby": "mostrar_ranque_no_lobby_competitivo",
            "modes": "modos",
            "all": "todos",
            "small_image": "imagem_pequena",
            "large_image": "imagem_grande",
            "range": "range",
            "show_rank_in_range": "mostrar_ranque_na_range",
            "startup": "inicialização",
            "game_launch_timeout": "atraso_execução_jogo",
            "presence_timeout": "atraso_presença",
            "show_github_link": "mostrar_link_github",
            "auto_launch_skincli": "abrir_skincli_automaticamente",
            "agent": "agente",
            "rank": "ranque",
            "map": "mapa",
        },
        "prints": {
            "config_modification": {
                "select_option": "selecione uma opção de configuração",
                "config_saved": "configuração salva! reinicie para as mudanças fazerem efeito.",
                "set_prompt": "definir valor para"
            },
            "startup": {
                "wait_for_rpc": "esperando por cliente rpc...",
                "discord_not_detected": "discord não detectado! iniciando jogo sem presença...",
                "starting_valorant": "iniciado VALORANT..",
                "startup_successful": "programa iniciado com sucesso, minimizando em 5 segundos...",
                "waiting_for_presence": "esperando pela presença...",
                "waiting_for_valorant": "esperando o VALORANT...",
                "autodetect_region": "tentando detectar região..",
                "autodetected_region": "região detectada:",
            },
            "presence": {
                "presence_running": "presença rodando!",
            },
            "systray": {
                "hiding_window": "minimizando janela...",
            },
            "errors": {
                "error_message": "o programa encontrou um erro: favor criar um issue com o traceback abaixo se o problema persistir:",
                "exit": "pressione enter para sair...",
            },
            "version_checker": {
                "update_available": "atualização disponível! baixe-a em",
                "checker_error": "incapaz de checar atualizações!",
            }
        },
        "presences": {
            "party_states": {
                "open": "Grupo Aberto",
                "solo": "Grupo Fechado (Solo)",
                "in_party": "Em um Grupo",
            },
            "client_states": {
                "away": "Ausente",
                "menu": "Nos Menus",
                "custom_setup": "Jogo Personalizado",
                "queue": "Na Fila",
                "pregame": "Pré-Jogo",
            },
            "team_names": {
                "TeamOne": "Defensor",
                "TeamTwo": "Atacante",
                "TeamSpectate": "Observador",
                "TeamOneCoaches": "Treinador dos Defensores",
                "TeamTwoCoaches": "Treinador dos Atacantes",
            },
            "modes": {
                "newmap": "Mapa Novo",
                "competitive": "Competitivo",
                "unrated": "Sem Classificação",
                "spikerush": "Disputa da Spike",
                "deathmatch": "Mata-Mata",
                "ggteam": "Disparada",
                "onefa": "Replicação",
                "custom": "Jogo Personalizado",
                "snowball": "Batalha Nevada",
                "swiftplay": "Frenético",
                "hurm": "Mata-Mata em Equipe",
                "": "Jogo Personalizado",
            },
            "pregame": {
                "selecting": "Selecionando",
                "locked": "Confirmado",
            },
            "leveling": {
                "level": "Nível",
                "ranked_rating": "CR",
            },
            "startup": {
                "loading": "Carregando",
                "view_github": "Ver no GitHub",
            }
        },
    },
    "ru-RU": {
        "author": "@teddn#6036, @kizn#6995",
        "config": {
            "version": "Версия",
            "region": "Регион",
            "client_id": "client_id",
            "presence_refresh_interval": "Интервал_проверки_статуса_дискорда",
            "locale": "язык",
            "presences": "статус_дискорда",
            "menu": "меню",
            "show_rank_in_comp_lobby": "показывать_ранг_в_лобби",
            "modes": "режимы",
            "all": "все",
            "small_image": "маленькое_изображение",
            "large_image": "большое_изображение",
            "range": "стрельбище",
            "show_rank_in_range": "показывать_ранг_на_стрельбище",
            "startup": "запуск",
            "game_launch_timeout": "таймер_запуска_игры",
            "presence_timeout": "таймер_проверки_статуса_дискорда",
            "show_github_link": "ссылка_на_github",
            "auto_launch_skincli": "авто_запуск_skincli",
            "agent": "агент",
            "rank": "ранг",
            "map": "карта",
        },
        "prints": {
            "config_modification": {
                "select_option": "выберите опцию",
                "config_saved": "конфиг сохранён! чтобы изменения вступили в силу перезапустите программу",
                "set_prompt": "установите значение для"
            },
            "startup": {
                "wait_for_rpc": "ожидание RPC",
                "discord_not_detected": "дискорд не запущен! запуск игры без RPC",
                "starting_valorant": "запуск VALORANT",
                "startup_successful": "программа успешно запущена, скрытие окна через 5 секунд",
                "waiting_for_presence": "получаю статус дискорда",
                "waiting_for_valorant": "ожидание VALORANT...",
                "autodetect_region": "автоопределяю регион",
                "autodetected_region": "регион:",
            },
            "presence": {
                "presence_running": "Дискорд запущен",
            },
            "systray": {
                "hiding_window": "скрытие окна",
            },
            "errors": {
                "error_message": "возникла ошибка: если проблема повторится, пожалуйста, создайте отчёт по ссылке ниже",
                "exit": "Нажмите ENTER для выхода",
            },
            "version_checker": {
                "update_available": "доступно обновление! Скачать - ",
                "checker_error": "невозможно проверить наличие обновления",
            }
        },
        "presences": {
            "party_states": {
                "open": "Открытая группа",
                "solo": "Соло",
                "in_party": "В группе",
            },
            "client_states": {
                "away": "Отошёл",
                "menu": "Меню",
                "custom_setup": "Настройка своей игры",
                "queue": "Очередь",
                "pregame": "Выбор агента...",
            },
            "team_names": {
                "TeamOne": "Защита",
                "TeamTwo": "Атака",
                "TeamSpectate": "Наблюдатель",
                "TeamOneCoaches": "Тренер защитников",
                "TeamTwoCoaches": "Тренер атакующих",
            },
            "modes": {
                "newmap": "Новая карта",
                "competitive": "Соревновательный",
                "unrated": "Без ранга",
                "spikerush": "Быстр. установка Spike",
                "deathmatch": "Бой насмерть",
                "ggteam": "Эскалация",
                "onefa": "Репликация",
                "custom": "Своя игра",
                "snowball": "Игра в снежки",
                "swiftplay": "Быстрая игра",
                "": "Своя игра",
            },
            "pregame": {
                "selecting": "Выбор...",
                "locked": "Выбран",
            },
            "leveling": {
                "level": "Уровень",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "Загрузка",
                "view_github": "GitHub",
            }
        }
    },
    "th-TH": {
        "author": "@Nack#2336, @TheMickeyz#3078",
        "config": {
            "version": "เวอร์ชัน",
            "region": "ภูมิภาค",
            "client_id": "ไอดี",
            "presence_refresh_interval": "ระยะเวลาในการรีเฟรช Presence",
            "locale": "ภาษา",
            "presences": "presences",
            "menu": "เมนู",
            "show_rank_in_comp_lobby": "โชว์แรงก์ในโหมดแรงก์",
            "modes": "โหมด",
            "all": "ทั้งหมด",
            "small_image": "รูปเล็ก",
            "large_image": "รูปใหญ่",
            "range": "โหมดฝึกซ้อม",
            "show_rank_in_range": "โชว์แรงก์ในโหมดฝึกซ้อม",
            "startup": "เริ่มอัตโนมัติ",
            "game_launch_timeout": "ระยะเวลาสูงสุดในการเปิดเกม",
            "presence_timeout": "ระยะเวลาสูงสุดของ Presence",
            "show_github_link": "แสดงลิงก์ GitHub",
            "auto_launch_skincli": "เปิด SkinCLI อัตโนมัติ",
            "agent": "เอเจนท์",
            "rank": "แรงก์",
            "map": "แผนที่",
        },
        "prints": {
            "config_modification": {
                "select_option": "เลือกการตั้งค่า",
                "config_saved": "ตั้งค่าสำเร็จ ! โปรดเปิดโปรแกรมใหม่เพื่อใช้งาน",
                "set_prompt": "ตั้งค่าเป็น"
            },
            "startup": {
                "wait_for_rpc": "กำลังรอ RPC",
                "discord_not_detected": "ไม่พบ Discord! กำลังเปิดเกมโดยไม่มี Presence...",
                "starting_valorant": "กำลังเปิด VALORANT",
                "startup_successful": "กำลังเริ่มทำงาน ปิดหน้าต่างในอีก 5 วินาที",
                "waiting_for_presence": "กำลังรอ Presence...",
                "waiting_for_valorant": "กำลังรอ VALORANT...",
                "autodetect_region": "กำลังตรวจหาภูมิภาค",
                "autodetected_region": "ภูมิภาค :",
            },
            "presence": {
                "presence_running": "Presence กำลังทำงานอยู่ !",
            },
            "systray": {
                "hiding_window": "ซ่อนหน้าต่าง",
            },
            "errors": {
                "error_message": "มีข้อผิดพลาด : หากยังมีปัญหาอยู่ โปรดเปิด Issue บน Github",
                "exit": "กด Enter เพื่อออก...",
            },
            "version_checker": {
                "update_available": "พบเวอร์ชั่นที่ใหม่กว่า ! ดาวน์โหลดได้ที่",
                "checker_error": "ไม่สามารถตรวจหาอัปเดตได้!",
            }
        },
        "presences": {
            "party_states": {
                "open": "ปาร์ตี้เปิด",
                "solo": "เดี่ยว",
                "in_party": "อยู่ในปาร์ตี้",
            },
            "client_states": {
                "away": "ไม่อยู่",
                "menu": "เมนู",
                "custom_setup": "สร้างห้อง",
                "queue": "อยู่ในคิว",
                "pregame": "กำลังเลือกเอเจนท์",
            },
            "team_names": {
                "TeamOne": "ฝั่งตั้งรับ",
                "TeamTwo": "ฝั่งบุก",
                "TeamSpectate": "ผู้ชม",
                "TeamOneCoaches": "โค้ชของฝั่งตั้งรับ",
                "TeamTwoCoaches": "โค้ชของฝั่งบุก",
            },
            "modes": {
                "newmap": "แมพใหม่",
                "competitive": "แรงก์",
                "unrated": "ธรรมดา",
                "spikerush": "Spike Rush",
                "deathmatch": "เดธแมตช์",
                "ggteam": "Escalation",
                "onefa": "โหมดตัวซ้ำ",
                "custom": "สร้างห้อง",
                "snowball": "สงครามหิมะ",
                "": "สร้างห้อง",
            },
            "pregame": {
                "selecting": "กำลังเลือกเอเจนท์",
                "locked": "เลือกเอเจนท์แล้ว",
            },
            "leveling": {
                "level": "ระดับ",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "กำลังโหลด",
                "view_github": "ดูใน GitHub",
            }
        },
    },
    "tr-TR": {
        "author": "@MKerem#2078 , @Ozefear#3083",
        "config": {
            "version": "versiyon",
            "region": "bölge",
            "client_id": "istemci_id",
            "presence_refresh_interval": "durum_yenileme_aralığı",
            "locale": "dil",
            "presences": "durumlar",
            "menu": "menü",
            "show_rank_in_comp_lobby": "rekabetçi_lobide_rütbe_göster",
            "modes": "modlar",
            "all": "hepsi",
            "small_image": "küçük_resim",
            "large_image": "büyük_resim",
            "range": "poligon",
            "show_rank_in_range": "poligonda_rütbeyi_göster",
            "startup": "başlangıç",
            "game_launch_timeout": "oyun_başlama_zaman_aşımı",
            "presence_timeout": "durum_zaman_aşımı",
            "show_github_link": "github_linkini_göster",
            "auto_launch_skincli": "skincli_otomatik_başlat",
            "agent": "ajan",
            "rank": "rank",
            "map": "harita",
        },
        "prints": {
            "config_modification": {
                "select_option": "Bir yapılandırma seçeneği seçin.",
                "config_saved": "Ayarlar kaydedildi! Değişikliklerin uygulanması için programı yeniden başlat.",
                "set_prompt": "için değer ayarla"
            },
            "startup": {
                "wait_for_rpc": "rpc istemcisi bekleniyor.",
                "discord_not_detected": "Discord algılanmadı! Oyun Discord durumu olmadan başlatılıyor...",
                "starting_valorant": "VALORANT başlatılıyor.",
                "startup_successful": "Programın çalıştırılması başarılı, pencere beş saniye içinde gizleniyor.",
                "waiting_for_presence": "Discord durumu için bekleniyor...",
                "waiting_for_valorant": "VALORANT bekleniyor...",
                "autodetect_region": "Bölge otomatik algılanmaya çalışılıyor.",
                "autodetected_region": "Otomatik algılanan bölge:",
            },
            "presence": {
                "presence_running": "Discord durumu çalışıyor!",
            },
            "systray": {
                "hiding_window": "Pencere gizleniyor.",
            },
            "errors": {
                "error_message": "Program bir hata ile karşılaştı: Bu sorun devam ederse lütfen aşağıdaki hata mesajı ile beraber bir issue oluşturun.",
                "exit": "Çıkmak için enter tuşuna basın...",
            },
            "version_checker": {
                "update_available": "Güncelleme mevcut! Buradan indir: ",
                "checker_error": "Güncellemeler kontrol edilemedi!",
            }
        },
        "presences": {
            "party_states": {
                "open": "Uygun",
                "solo": "Solo",
                "in_party": "Takımda",
            },
            "client_states": {
                "away": "Uzakta",
                "menu": "Menü",
                "custom_setup": "Özel Oyun",
                "queue": "Sırada",
                "pregame": "Oyun Öncesi",
            },
            "team_names": {
                "TeamOne": "Savunma",
                "TeamTwo": "Saldırı",
                "TeamSpectate": "İzleyici",
                "TeamOneCoaches": "Savunma Koçu",
                "TeamTwoCoaches": "Saldırı Koçu",
            },
            "modes": {
                "newmap": "Yeni Harita",
                "competitive": "Rekabete Dayalı",
                "unrated": "Derecesiz",
                "spikerush": "Spike'a Hücum",
                "deathmatch": "Ölüm Kalım Savaşı",
                "ggteam": "Tırmanış",
                "onefa": "Kopya",
                "custom": "Özel Oyun",
                "snowball": "Kartopu Çatışması",
                "swiftplay": "Tam Gaz",
                "hurm": "Takımlı Ölüm Kalım Savaşı",
                "": "Özel Maç",
            },
            "pregame": {
                "selecting": "Ajan Seçiyor",
                "locked": "Kilitlendi",
            },
            "leveling": {
                "level": "Seviye",
                "ranked_rating": "KP",
            },
            "startup": {
                "loading": "Yükleniyor...",
                "view_github": "GitHub'da bak.",
            }
        },
    },
    "vi-VN": {
        "author": "@Mistral#9699",
        "config": {
            "version": "phiên_bản",
            "region": "khu_vực",
            "client_id": "id_client",
            "presence_refresh_interval": "thời_gian_làm_mới_presence",
            "locale": "ngôn_ngữ",
            "presences": "presences",
            "menu": "menu",
            "show_rank_in_comp_lobby": "hiện_rank_trong_sảnh",
            "modes": "chế_độ",
            "all": "tất_cả",
            "small_image": "ảnh_bé",
            "large_image": "ảnh_to",
            "range": "phạm_vi",
            "show_rank_in_range": "hiện_rank_trong_phòng_tập",
            "startup": "khởi_động",
            "game_launch_timeout": "thời_gian_cho_khởi_động_game",
            "presence_timeout": "thời_gian_cho_presence",
            "show_github_link": "hiện_link_github",
            "auto_launch_skincli": "tự_bật_skincli",
            "agent": "đặc_vụ",
            "rank": "rank",
            "map": "bản_đồ",
        },
        "prints": {
            "config_modification": {
                "select_option": "chọn một tuỳ chọn cấu hình",
                "config_saved": "cấu hình đã được lưu! restart phần mềm để các thay đổi có hiệu lực.",
                "set_prompt": "chọn một giá trị"
            },
            "startup": {
                "wait_for_rpc": "đang đợi rpc client.",
                "discord_not_detected": "không tìm thấy discord! đang bắt đầu game mà không có presence...",
                "starting_valorant": "đang khởi động VALORANT",
                "startup_successful": "khởi động thành công, sẽ ẩn cửa sổ sau 5 giây",
                "waiting_for_presence": "đang đợi presence...",
                "waiting_for_valorant": "đang đợi VALORANT...",
                "autodetect_region": "đang thử tự tìm kiếm khu vực game của bạn.",
                "autodetected_region": "đã tìm thấy khu vực:",
            },
            "presence": {
                "presence_running": "presence đang chạy!",
            },
            "systray": {
                "hiding_window": "ẩn cửa sổ",
            },
            "errors": {
                "error_message": "phần mềm đã gặp một lỗi: hãy tạo một issues với traceback bên dưới!",
                "exit": "bấm enter để thoát...",
            },
            "version_checker": {
                "update_available": "đã có bản cập nhật mới! tải nó về tại",
                "checker_error": "không thể kiểm tra bản cập nhật mới!",
            }
        },
        "presences": {
            "party_states": {
                "open": "Tổ đội mở",
                "solo": "Solo",
                "in_party": "Trong một tổ đội",
            },
            "client_states": {
                "away": "AFK",
                "menu": "Menu",
                "custom_setup": "Custom",
                "queue": "Trong hàng chờ",
                "pregame": "Chuẩn bị vào game",
            },
            "team_names": {
                "TeamOne": "Thủ",
                "TeamTwo": "Công",
                "TeamSpectate": "Khán giả",
                "TeamOneCoaches": "Huấn luyện viên bên Thủ",
                "TeamTwoCoaches": "Huấn luyện viên bên Công",
            },
            "modes": {
                "newmap": "Map mới",
                "competitive": "Đấu hạng",
                "unrated": "Đấu thường",
                "spikerush": "Đặt spike nhanh",
                "deathmatch": "Tử chiến",
                "ggteam": "Leo thang",
                "onefa": "Nhân bản",
                "custom": "Custom",
                "snowball": "Snowball Fight",
                "": "Tuỳ chỉnh",
            },
            "pregame": {
                "selecting": "Đang chọn",
                "locked": "Locked",
            },
            "leveling": {
                "level": "Level",
                "ranked_rating": "RR",
            },
            "startup": {
                "loading": "Đang tải",
                "view_github": "Xem trên GitHub",
            }
        },
    },
    "pl-PL": {
        "author": "@kyanbasu",  #https://github.com/kyanbasu
        "config": {
            "version": "wersja",
            "region": "region",
            "client_id": "id_klienta",
            "presence_refresh_interval": "interwał_odświeżania_klienta",
            "locale": "język",
            "presences": "presences",
            "menu": "menu",
            "show_rank_in_comp_lobby": "pokazuj_range_w_rankingowym_lobby",
            "modes": "tryby",
            "all": "wszystkie",
            "small_image": "small_image",
            "large_image": "large_image",
            "range": "strzelnica",
            "show_rank_in_range": "pokazuj_range_w_strzelnicy",
            "startup": "startup",
            "game_launch_timeout": "game_launch_timeout",
            "presence_timeout": "presence_timeout",
            "show_github_link": "show_github_link",
            "auto_launch_skincli": "auto_launch_skincli",
            "agent": "agent",
            "rank": "ranga",
            "map": "mapa",
        },
        "prints": {
            "config_modification": {
                "select_option": "wybierz opcję konfiguracyjną",
                "config_saved": "konfiguracja zapisana! uruchom ponownie program, aby zatwierdzić zmiany.",
                "set_prompt": "ustaw wartość dla"
            },
            "startup": {
                "wait_for_rpc": "czekanie na rpc client",
                "discord_not_detected": "discord został nie wykryty! włączanie gry bez presence...",
                "starting_valorant": "włączanie VALORANT",
                "startup_successful": "pomyślne uruchomienie programu, ukrycie okna za 5 sekund",
                "waiting_for_presence": "czekanie na presence...",
                "waiting_for_valorant": "czekanie VALORANT...",
                "autodetect_region": "próba automatycznego wykrycia regionu",
                "autodetected_region": "automatycznie wykryty region:",
            },
            "presence": {
                "presence_running": "presence running!",
            },
            "systray": {
                "hiding_window": "ukrywanie okna",
            },
            "errors": {
                "error_message": "program napotkał błąd: proszę utworzyć problem z poniższym śledzeniem, jeśli problem będzie się powtarzał",
                "exit": "wciśnij enter aby wyjść...",
            },
            "version_checker": {
                "update_available": "jest dostępna aktualizacja! pobierz ją na",
                "checker_error": "nie można sprawdzić aktualizacji!",
            }
        },
        "presences": {
            "party_states": {
                "open": "Otwarta Grupa",
                "solo": "Solo",
                "in_party": "W Grupie",
            },
            "client_states": {
                "away": "AFK",
                "menu": "Menu",
                "custom_setup": "Własne Ustawienia",
                "queue": "Kolejka",
                "pregame": "Pregame",
            },
            "team_names": {
                "TeamOne": "Broniący",
                "TeamTwo": "Atakujący",
                "TeamSpectate": "Obsererwujący",
                "TeamOneCoaches": "Coach Broniących",
                "TeamTwoCoaches": "Coach Atakujących",
            },
            "modes": {
                "newmap": "Nowa Mapa",
                "competitive": "Rankingowy",
                "unrated": "Nierankingowy",
                "spikerush": "Gorączka Spike",
                "deathmatch": "Deathmatch",
                "ggteam": "Eskalacja",
                "onefa": "Replikacja",
                "custom": "Niestandardowy",
                "snowball": "Bitwa Na Śnieżki",
                "": "Niestandardowy",
            },
            "pregame": {
                "selecting": "Wybieranie",
                "locked": "Zablokowano",
            },
            "leveling": {
                "level": "Poziom",
                "ranked_rating": "OR",
            },
            "startup": {
                "loading": "Ładowanie",
                "view_github": "Sprawdź na GitHub",
            }
        },
    },
    "zh-CN": {},
    "zh-TW": {
        "author": "@ScarZ", #https://github.com/scarrrr316
        "config": {
            "version": "版本",
            "region": "地區",
            "client_id": "客戶端ID",
            "presence_refresh_interval": "狀態刷新時間",
            "locale": "語言",
            "presences": "狀態顯示",
            "menu": "主選單",
            "show_rank_in_comp_lobby": "在競技模式時顯示牌階",
            "modes": "模式",
            "all": "全部",
            "small_image": "小圖片",
            "large_image": "大圖片",
            "range": "訓練場",
            "show_rank_in_range": "在訓練場時顯示牌階",
            "startup": "啟動",
            "game_launch_timeout": "遊戲啟動超時",
            "presence_timeout": "狀態顯示超時",
            "show_github_link": "顯示Github鏈接",
            "auto_launch_skincli": "自動啟動皮膚CLI",
            "agent": "特務",
            "rank": "牌階",
            "map": "地圖",
        },
        "prints": {
            "config_modification": {
                "select_option": "選擇一個設置選項",
                "config_saved": "設置已保存! 重啟以生效.",
                "set_prompt": "設置值:"
            },
            "startup": {
                "wait_for_rpc": "正在等待rpc客戶端",
                "discord_not_detected": "沒有檢測到Discord! 正在沒狀態顯示的情況下啟動遊戲...",
                "starting_valorant": "正在啟動 VALORANT",
                "startup_successful": "程式啟動成功,將會在5秒內隱藏視窗",
                "waiting_for_presence": "正在等待狀態顯示...",
                "waiting_for_valorant": "正在等待VALORANT...",
                "autodetect_region": "嘗試自動檢測區域",
                "autodetected_region": "已自動檢測區域:",
            },
            "presence": {
                "presence_running": "正在顯示狀態!",
            },
            "systray": {
                "hiding_window": "正在隱藏視窗",
            },
            "errors": {
                "error_message": "程式遇到錯誤: 如果問題仍然存在, 請使用下面的跟蹤記錄在Github上創建一個Issue ",
                "exit": "按Enter退出...",
            },
            "version_checker": {
                "update_available": "有新版本可供下載! 下載地址:",
                "checker_error": "無法檢查更新!",
            }
        },
        "presences": {
            "party_states": {
                "open": "公開房間",
                "solo": "單人",
                "in_party": "在房間中",
            },
            "client_states": {
                "away": "暫離",
                "menu": "主選單",
                "custom_setup": "自定對戰準備中",
                "queue": "列隊等待中",
                "pregame": "特務選擇中",
            },
            "team_names": {
                "TeamOne": "守備方",
                "TeamTwo": "攻擊方",
                "TeamSpectate": "觀戰者",
                "TeamOneCoaches": "守備方教練",
                "TeamTwoCoaches": "攻擊方教練",
            },
            "modes": {
                "newmap": "新地圖",
                "competitive": "競技模式",
                "unrated": "一般模式",
                "spikerush": "輻能搶攻戰",
                "deathmatch": "死鬥模式",
                "ggteam": "超激進戰",
                "onefa": "複製亂戰",
                "custom": "自定對戰",
                "snowball": "打雪仗",
                "swiftplay": "超速衝點",
                "hurm": "團隊死鬥",
                "": "自定對戰",
            },
            "pregame": {
                "selecting": "選擇中",
                "locked": "已鎖定",
            },
            "leveling": {
                "level": "等級",
                "ranked_rating": "競技評分",
            },
            "startup": {
                "loading": "正在加載",
                "view_github": "在Github上查看",
            }
        },
    },

}


--- .\presets\valorant\src\localization\localization.py ---

from InquirerPy import inquirer
from .locales import Locales

class Localizer:

    locale = "en-US"
    config = None

    @staticmethod
    def get_localized_text(*keys):

        def get_default(*keys):
            localized = Locales["en-US"]
            for key in keys:
                localized = localized.get(key)
            return localized

        try:
            localized = Locales[Localizer.locale]
            for key in keys:
                if localized is None:
                    get_default(*keys)
                localized = localized.get(key)
            if localized is not None:
                return localized
        except:
            return get_default(*keys)


    @staticmethod
    def get_config_key(key):
        try:
            for k,value in Locales[Localizer.locale]["config"].items():
                #print(f"{k}/{value}")
                if k == key:
                    return value
            return key
        except:
            return key

    @staticmethod
    def unlocalize_key(key):
        for k,value in Locales[Localizer.locale]["config"].items():
            #print(f"{k}/{value}")
            if value == key:
                return k
        return key

    @staticmethod
    def get_config_value(*keys):
        localized_keys = [Localizer.get_config_key(key) for key in keys]
        result = Localizer.config
        for key in localized_keys:
            result = result[key]
        return result

    @staticmethod
    def set_locale(config):
        for locale,data in Locales.items():
            if data != {}:
                for key,value in data["config"].items():
                    if key == "locale" and value in config.keys():
                        Localizer.locale = config[value][0]

    @staticmethod
    def prompt_locale(config):
        locale = config["locale"]
        current = locale[0]
        options = locale[1]
        choice = inquirer.select(
            message=f"select your locale (language)",
            default=current,
            choices={option:option for option in options},
            pointer=">"
        )
        choice = choice.execute()
        locale[0] = choice 
        return config

--- .\presets\valorant\src\presence\presence.py ---

from pypresence import Presence as PyPresence
from pypresence.exceptions import InvalidPipe
from InquirerPy.utils import color_print
import time, sys, traceback, os, ctypes, asyncio, websockets, json, base64, ssl

ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

from ..utilities.config.app_config import Config
from ..content.content_loader import Loader
from ..localization.localization import Localizer
from .presences import (ingame,menu,startup,pregame)

kernel32 = ctypes.WinDLL('kernel32')
user32 = ctypes.WinDLL('user32')
hWnd = kernel32.GetConsoleWindow()

class Presence:

    def __init__(self,config):
        self.config = config
        self.client = None
        self.saved_locale = None
        try:
            self.rpc = PyPresence(client_id=str(Localizer.get_config_value("client_id")))
            self.rpc.connect()
        except InvalidPipe as e:
            raise Exception(e)
        self.content_data = {}
    
    def main_loop(self):
        # async with websockets.connect(f'wss://riot:{self.client.lockfile["password"]}@localhost:{self.client.lockfile["port"]}', ssl=ssl_context) as websocket:
        #     await websocket.send('[5, "OnJsonApiEvent_chat_v4_presences"]')    # subscribing to presence event
            
        #     while True:
        #         response = await websocket.recv()
        #         if response != "":
        #             response = json.loads(response)
        #             if response[2]['data']['presences'][0]['puuid'] == self.client.puuid:
        #                 presence_data = json.loads(base64.b64decode((response[2]['data']['presences'][0]['private'])))
        #                 if presence_data is not None:
        #                     self.update_presence(presence_data["sessionLoopState"],presence_data)
        #                     # print(presence_data)
        #                 else:
        #                     os._exit(1)

        #                 if Localizer.locale != self.saved_locale:
        #                     self.saved_locale = Localizer.locale
        #                     self.content_data = Loader.load_all_content(self.client)


        while True:
            presence_data = self.client.fetch_presence()
            if presence_data is not None:
                self.update_presence(presence_data["sessionLoopState"],presence_data)
                # print(presence_data)
            else:
                os._exit(1)

            if Localizer.locale != self.saved_locale:
                self.saved_locale = Localizer.locale
                self.content_data = Loader.load_all_content(self.client)
            time.sleep(Localizer.get_config_value("presence_refresh_interval"))


    def init_loop(self):
        try:
            self.content_data = Loader.load_all_content(self.client)
            color_print([("LimeGreen bold", Localizer.get_localized_text("prints","presence","presence_running"))])
            presence_data = self.client.fetch_presence()

            if presence_data is not None:
                self.update_presence(presence_data["sessionLoopState"],presence_data)
                
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

            #asyncio.ensure_future(self.main_loop())
            self.main_loop()

                    
        except Exception as e:
            user32.ShowWindow(hWnd, 1)
            kernel32.SetConsoleMode(kernel32.GetStdHandle(-10), (0x4|0x80|0x20|0x2|0x10|0x1|0x40|0x100))
            color_print([("Red bold",Localizer.get_localized_text("prints","errors","error_message"))])
            traceback.print_exc()
            input(Localizer.get_localized_text("prints","errors","exit"))
            os._exit(1)

    def update_presence(self,ptype,data=None):
        presence_types = {
            "startup": startup,
            "MENUS": menu,
            "PREGAME": pregame,
            "INGAME": ingame,
        }
        if ptype in presence_types.keys():
            presence_types[ptype].presence(self.rpc,client=self.client,data=data,content_data=self.content_data,config=self.config)

--- .\presets\valorant\src\presence\presence_utilities.py ---

import iso8601
from ..utilities.logging import Logger 
from ..localization.localization import Localizer
debug = Logger.debug

class Utilities:

    @staticmethod 
    def build_party_state(data):
        party_state = Localizer.get_localized_text("presences","party_states","solo")     
        if data["partySize"] > 1:
            party_state = Localizer.get_localized_text("presences","party_states","in_party")   
        elif data["partyAccessibility"] == "OPEN":
            party_state = Localizer.get_localized_text("presences","party_states","open")

        party_size = [data["partySize"],data["maxPartySize"]] if data["partySize"] > 1 or data["partyAccessibility"] == "OPEN" else None
        if party_size is not None:
            if party_size[0] == 0: 
                party_size[0] = 1
            if party_size[1] < 1:
                party_size[1] = 1
        return party_state, party_size 

    @staticmethod 
    def iso8601_to_epoch(time):
        if time == "0001.01.01-00.00.00":
            return None
        split = time.split("-")
        split[0] = split[0].replace(".","-")
        split[1] = split[1].replace(".",":")
        split = "T".join(i for i in split)
        split = iso8601.parse_date(split).timestamp() #converts iso8601 to epoch
        return split

    @staticmethod 
    def fetch_rank_data(client,content_data):
        try:
            mmr = client.fetch_mmr()["QueueSkills"]["competitive"]["SeasonalInfoBySeasonID"][content_data["season"]["season_uuid"]]
        except:
            return "rank_0","Rank not found"
        rank_data = {}
        for tier in content_data["comp_tiers"]:
            if tier["id"] == mmr["CompetitiveTier"]:
                rank_data = tier
        rank_image = f"rank_{rank_data['id']}"
        rank_text = f"{rank_data['display_name_localized']} - {mmr['RankedRating']}{Localizer.get_localized_text('presences','leveling','ranked_rating')}" + (f" // #{mmr['LeaderboardRank']}" if mmr['LeaderboardRank'] != 0 else "") 

        return rank_image, rank_text
        
    @staticmethod 
    def fetch_map_data(coregame_data,content_data):
        for gmap in content_data["maps"]:
            if gmap["path"] == coregame_data["MapID"]:
                return gmap["display_name"], gmap["display_name_localized"]
        return "", ""
 
    @staticmethod 
    def fetch_agent_data(uuid,content_data):
        for agent in content_data["agents"]:
            if agent["uuid"] == uuid:
                agent_image = f"agent_{agent['display_name'].lower().replace('/','')}"
                agent_name = agent['display_name_localized']
                return agent_image, agent_name
        return "rank_0","?"

    @staticmethod
    def fetch_mode_data(data, content_data):
        image = f"mode_{data['queueId'] if data['queueId'] in content_data['modes_with_icons'] else 'discovery'}"
        mode_name = content_data['queue_aliases'][data['queueId']] if data["queueId"] in content_data["queue_aliases"].keys() else "Custom"
        mode_name = Utilities.localize_content_name(mode_name, "presences", "modes", data["queueId"])
        return image,mode_name

    @staticmethod 
    def get_content_preferences(client,pref,presence,player_data,coregame_data,content_data):
        if pref == Localizer.get_localized_text("config", "rank"):
            return Utilities.fetch_rank_data(client,content_data)
        if pref == Localizer.get_localized_text("config", "map"): 
            gmap = Utilities.fetch_map_data(coregame_data,content_data)
            return f"splash_{gmap[0].lower()}", gmap[1]
        if pref == Localizer.get_localized_text("config", "agent"): 
            return Utilities.fetch_agent_data(player_data["CharacterID"],content_data)

    @staticmethod
    def localize_content_name(default,*keys):
        localized = Localizer.get_localized_text(*keys)
        if localized is not None:
            return localized 
        return default

    @staticmethod 
    def get_join_state(client,config,presence=None):
        '''
        if presence is None:
            presence = client.fetch_presence()
        base_api_url = "https://colinhartigan.github.io/valorant-rpc?redir={redirect}&type={req_type}"
        base_api_url = f"{base_api_url}&region={client.region}&playername={client.player_name}&playertag={client.player_tag}" # add on static values (region/playername)
        if int(presence["partySize"]) < int(presence["maxPartySize"]):
            if presence["partyAccessibility"] == "OPEN" and config["presences"]["menu"]["show_join_button_with_open_party"]:
                debug(f"join link: " + base_api_url.format(redirect=f"/valorant/join/{presence['partyId']}"))
                return [{"label":"Join","url":base_api_url.format(redirect=f"/valorant/join/{presence['partyId']}",req_type="join")}]
            
            if presence["partyAccessibility"] == "CLOSED" and config["presences"]["menu"]["allow_join_requests"]:
                return [{"label":"Request to Join","url":base_api_url.format(redirect=f"/valorant/request/{presence['partyId']}/{client.puuid}",req_type="request")}]
        '''

        return None


--- .\presets\valorant\src\presence\presences\ingame.py ---

from .ingame_presences.session import Game_Session
from .ingame_presences.range import Range_Session
from valclient.exceptions import PhaseError

def presence(rpc,client=None,data=None,content_data=None,config=None):
    try:
        coregame = client.coregame_fetch_player()

        if coregame is not None:
            match_id = coregame["MatchID"]
            if data["provisioningFlow"] != "ShootingRange":
                try:
                    session = Game_Session(rpc,client,data,match_id,content_data,config)
                    session.main_loop()
                except:
                    pass
            else:
                session = Range_Session(rpc,client,data,match_id,content_data,config)
                session.main_loop()

    except PhaseError:
        pass


--- .\presets\valorant\src\presence\presences\menu.py ---

from .menu_presences import (default,queue,custom_setup)

def presence(rpc,client=None,data=None,content_data=None,config=None):
    state_types = {
        "DEFAULT": default,
        "MATCHMAKING": queue,
        "CUSTOM_GAME_SETUP": custom_setup,
    }
    if data['partyState'] in state_types.keys():
        state_types[data['partyState']].presence(rpc,client=client,data=data,content_data=content_data,config=config)

--- .\presets\valorant\src\presence\presences\pregame.py ---

from ..presence_utilities import Utilities
from ...localization.localization import Localizer
from valclient.exceptions import PhaseError
import time

def presence(rpc,client=None,data=None,content_data=None,config=None):
    party_state,party_size = Utilities.build_party_state(data)
    
    try:
        pregame = client.pregame_fetch_player()
        match_id = pregame["MatchID"]
        pregame_data = client.pregame_fetch_match(match_id)
        puuid = client.puuid

        pregame_player_data = {}
        for player in pregame_data["AllyTeam"]["Players"]:
            if player["Subject"] == puuid:
                pregame_player_data = player

        pregame_end_time = (pregame_data['PhaseTimeRemainingNS'] // 1000000000) + time.time()

        agent_image, agent_name = Utilities.fetch_agent_data(pregame_player_data["CharacterID"],content_data)
        select_state = Localizer.get_localized_text("presences","pregame","locked") if pregame_player_data["CharacterSelectionState"] == "locked" else Localizer.get_localized_text("presences","pregame","selecting")
        small_image, mode_name = Utilities.fetch_mode_data(data,content_data)

        rpc.update(
            state=party_state,
            details=f"{Localizer.get_localized_text('presences','client_states','pregame')} - {mode_name}",
            end=pregame_end_time,
            large_image=agent_image,
            large_text=f"{select_state} - {agent_name}",
            small_image=small_image,
            small_text=mode_name,
            party_size=party_size,
            party_id=data["partyId"],
        )
    except PhaseError:
        pass

--- .\presets\valorant\src\presence\presences\startup.py ---

from ...localization.localization import Localizer

def presence(rpc,client=None,data=None,content_data=None,config=None):
    rpc.update(
        state=Localizer.get_localized_text("presences","startup","loading"),
        large_image="game_icon",
        large_text="VALORANT-rpc",
        buttons=[{
            'label':Localizer.get_localized_text("presences","startup","view_github"),
            'url':"https://github.com/colinhartigan/valorant-rpc"
        }] if Localizer.get_config_value("startup","show_github_link") else None
    )

--- .\presets\valorant\src\presence\presences\ingame_presences\range.py ---

import time

from ..menu_presences.away import presence as away
from ...presence_utilities import Utilities
from ....localization.localization import Localizer

class Range_Session:

    def __init__(self,rpc,client,data,match_id,content_data,config):
        self.rpc = rpc
        self.client = client
        self.config = config
        self.content_data = content_data
        self.match_id = match_id  
        self.puuid = self.client.puuid

        data["MapID"] = "/Game/Maps/Poveglia/Range" # hotfix :)
        self.start_time = time.time()
        self.map_name, self.mode_name = Utilities.fetch_map_data(data, content_data)
        self.map_image = "splash_range"
        self.small_image = "mode_unrated"
        self.small_text = None

        if Localizer.get_config_value("presences","modes","range","show_rank_in_range"):
            self.small_image, self.small_text = Utilities.fetch_rank_data(self.client,self.content_data)

    def main_loop(self):
        presence = self.client.fetch_presence()
        while presence is not None and presence["sessionLoopState"] == "INGAME":
            try:
                presence = self.client.fetch_presence()
                is_afk = presence["isIdle"]
                if is_afk:
                    away(self.rpc,self.client,presence,self.content_data,self.config)  
                else:
                    party_state,party_size = Utilities.build_party_state(presence)

                    self.rpc.update(
                        state=party_state,
                        details=self.mode_name,
                        start=self.start_time,
                        large_image=self.map_image,
                        large_text=self.map_name,
                        small_image=self.small_image,
                        small_text=self.small_text,
                        party_size=party_size,
                        party_id=presence["partyId"],
                    )

                time.sleep(Localizer.get_config_value("presence_refresh_interval"))
            except:
                return

--- .\presets\valorant\src\presence\presences\ingame_presences\session.py ---

import time

from ...presence_utilities import Utilities
from ..menu_presences.away import presence as away
from ....localization.localization import Localizer
from valclient.exceptions import PhaseError

class Game_Session:

    def __init__(self,rpc,client,data,match_id,content_data,config):
        self.rpc = rpc
        self.client = client
        self.config = config
        self.content_data = content_data
        self.match_id = match_id 
        self.puuid = self.client.puuid

        self.start_time = time.time()
        self.large_text = ""
        self.large_image = ""
        self.small_text = ""
        self.small_image = ""
        self.mode_name = ""

        self.large_pref = Localizer.get_config_value("presences","modes","all","large_image",0)
        self.small_pref = Localizer.get_config_value("presences","modes","all","small_image",0)

        self.build_static_states()

    def build_static_states(self):
        # generate agent, map etc.
        presence = self.client.fetch_presence()
        try:
            coregame_data = self.client.coregame_fetch_match(self.match_id)
        except PhaseError:
            raise Exception
        coregame_player_data = {}
        for player in coregame_data["Players"]:
            if player["Subject"] == self.puuid:
                coregame_player_data = player

        self.large_image, self.large_text = Utilities.get_content_preferences(self.client,self.large_pref,presence,coregame_player_data,coregame_data,self.content_data)
        self.small_image, self.small_text = Utilities.get_content_preferences(self.client,self.small_pref,presence,coregame_player_data,coregame_data,self.content_data)
        _, self.mode_name = Utilities.fetch_mode_data(presence,self.content_data)

    def main_loop(self):
        presence = self.client.fetch_presence()
        while presence is not None and presence["sessionLoopState"] == "INGAME":
            presence = self.client.fetch_presence()
            is_afk = presence["isIdle"]
            if is_afk:
                away(self.rpc,self.client,presence,self.content_data,self.config)  
            else:
                party_state,party_size = Utilities.build_party_state(presence)
                my_score,other_score = presence["partyOwnerMatchScoreAllyTeam"],presence["partyOwnerMatchScoreEnemyTeam"]

                self.rpc.update(
                    state=party_state,
                    details=f"{self.mode_name} // {my_score} - {other_score}",
                    start=self.start_time,
                    large_image=self.large_image,
                    large_text=self.large_text,
                    small_image=self.small_image,
                    small_text=self.small_text,
                    party_size=party_size,
                    party_id=presence["partyId"],
                    instance=True,
                )

            time.sleep(Localizer.get_config_value("presence_refresh_interval"))

--- .\presets\valorant\src\presence\presences\menu_presences\away.py ---

from ....localization.localization import Localizer
from ...presence_utilities import Utilities

def presence(rpc,client=None,data=None,content_data=None,config=None):    
    party_state,party_size = Utilities.build_party_state(data)
    small_image, mode_name = Utilities.fetch_mode_data(data,content_data)
    buttons = Utilities.get_join_state(client,config,data)
    small_text = mode_name

    if data["queueId"] == "competitive" and Localizer.get_config_value("presences","menu","show_rank_in_comp_lobby"): 
        small_image, small_text = Utilities.fetch_rank_data(client,content_data)

    

    rpc.update(
        state=party_state,
        details=f"{Localizer.get_localized_text('presences','client_states','away')} - {mode_name}",
        large_image="game_icon_yellow",
        large_text=f"{Localizer.get_localized_text('presences','leveling','level')} {data['accountLevel']}",
        small_image=small_image,
        small_text=small_text,
        party_size=party_size,
        party_id=data["partyId"],
        buttons=buttons
    )


--- .\presets\valorant\src\presence\presences\menu_presences\custom_setup.py ---

from ...presence_utilities import Utilities
from ....localization.localization import Localizer

from .away import presence as away

def presence(rpc,client=None,data=None,content_data=None,config=None):
    is_afk = data["isIdle"]
    if is_afk:
        away(rpc,client,data,content_data,config)  
   
    else: 
        party_state,party_size = Utilities.build_party_state(data)
        data["MapID"] = data["matchMap"]
        game_map,map_name = Utilities.fetch_map_data(data,content_data)
        team = content_data["team_image_aliases"][data["customGameTeam"]] if data["customGameTeam"] in content_data["team_image_aliases"] else "game_icon_white"
        team_patched = content_data["team_aliases"][data["customGameTeam"]] if data["customGameTeam"] in content_data["team_aliases"].keys() else None
        team_patched = Utilities.localize_content_name(team_patched, "presences", "team_names", data["customGameTeam"])
        buttons = Utilities.get_join_state(client,config,data)

        rpc.update(
            state=party_state,
            details=Localizer.get_localized_text("presences","client_states","custom_setup"),
            large_image=f"splash_{game_map.lower()}",
            large_text=map_name,
            small_image=team,
            small_text=team_patched,
            party_size=party_size,
            party_id=data["partyId"],
            buttons=buttons
        )

--- .\presets\valorant\src\presence\presences\menu_presences\default.py ---

from ...presence_utilities import Utilities
from ....localization.localization import Localizer

from .away import presence as away

def presence(rpc,client=None,data=None,content_data=None,config=None):
    is_afk = data["isIdle"]
    if is_afk:
        away(rpc,client,data,content_data,config)  
     
    else:
        party_state,party_size = Utilities.build_party_state(data)
        small_image, mode_name = Utilities.fetch_mode_data(data,content_data)
        small_text = mode_name
        buttons = Utilities.get_join_state(client,config,data)

        if data["queueId"] == "competitive" and Localizer.get_config_value("presences","menu","show_rank_in_comp_lobby"): 
            small_image, small_text = Utilities.fetch_rank_data(client,content_data)

        rpc.update(
            state=party_state,
            details=f"{Localizer.get_localized_text('presences','client_states','menu')} - {mode_name}",
            large_image="game_icon",
            large_text=f"{Localizer.get_localized_text('presences','leveling','level')} {data['accountLevel']}",
            small_image=small_image,
            small_text=small_text,
            party_size=party_size,
            party_id=data["partyId"],
            buttons=buttons
        )

--- .\presets\valorant\src\presence\presences\menu_presences\queue.py ---

from ...presence_utilities import Utilities
from ....localization.localization import Localizer

def presence(rpc,client=None,data=None,content_data=None,config=None):
    
    party_state,party_size = Utilities.build_party_state(data)
    start_time = Utilities.iso8601_to_epoch(data['queueEntryTime'])
    small_image, mode_name = Utilities.fetch_mode_data(data, content_data)
    small_text = mode_name
    
    rpc.update(
        state=party_state,
        details=f"{Localizer.get_localized_text('presences','client_states','queue')} - {mode_name}",
        start=start_time,
        large_image="game_icon_white",
        large_text=f"{Localizer.get_localized_text('presences','leveling','level')} {data['accountLevel']}",
        small_image=small_image,
        small_text=small_text,
        party_size=party_size,
        party_id=data["partyId"],
    )


--- .\presets\valorant\src\utilities\filepath.py ---

import os
import sys

class Filepath:
    @staticmethod 
    def get_path(relative_path):
        if hasattr(sys, '_MEIPASS'): 
            return os.path.join(sys._MEIPASS, relative_path)
        return os.path.join(os.path.abspath("."), relative_path)

    @staticmethod 
    def get_appdata_folder():
        return Filepath.get_path(os.path.join(os.getenv('APPDATA'), 'valorant-rpc'))

    @staticmethod
    def get_programdata_folder():
        return Filepath.get_path(os.path.join(os.getenv('PROGRAMDATA'), 'valorant-tools'))

--- .\presets\valorant\src\utilities\killable_thread.py ---

import threading

class Thread(threading.Thread):
    """Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition."""

    def __init__(self,  *args, **kwargs):
        super(Thread, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()

    def stop(self):
        self._stop_event.set()

    def stopped(self):
        return self._stop_event.is_set()

--- .\presets\valorant\src\utilities\logging.py ---

import logging, os, pathlib
from .filepath import Filepath

class Logger:
    
    @staticmethod
    def create_logger():
        # create logger
        os.makedirs(Filepath.get_path(os.path.join(Filepath.get_appdata_folder())), exist_ok=True)
        logging.basicConfig(filename=Filepath.get_path(os.path.join(Filepath.get_appdata_folder(), 'rpc.log')),
                            filemode='w+',
                            format='%(asctime)s.%(msecs)d %(name)s %(levelname)s %(message)s',
                            datefmt='%H:%M:%S',
                            level=logging.DEBUG)

        logger = logging.getLogger('rpc')
        logger.debug("created log")

    @staticmethod 
    def debug(data):
        logger = logging.getLogger('rpc')
        logger.debug(data)

--- .\presets\valorant\src\utilities\processes.py ---

import psutil
import os

class Processes:

    @staticmethod
    def are_processes_running(required_processes=["VALORANT-Win64-Shipping.exe", "RiotClientServices.exe"]):
        processes = []
        for proc in psutil.process_iter():
            processes.append(proc.name())
        
        return set(required_processes).issubset(processes)

    @staticmethod
    def is_program_already_running():
        processes = []
        for proc in psutil.process_iter():
            processes.append(proc.name())

        if len([proc for proc in processes if proc == "valorant-rpc.exe"]) > 2:
            return True

        return False

--- .\presets\valorant\src\utilities\program_data.py ---

import os, sys, json
from InquirerPy.utils import color_print

from .filepath import Filepath

class Program_Data:

    installs_path = os.path.expandvars("%PROGRAMDATA%\\valorant-tools\\installs.json")

    @staticmethod
    def update_file_location():
        Program_Data.check_for_folder()
        if getattr(sys, 'frozen', False):
            path = sys.executable
        else:
            color_print([("Yellow","running in a testing environment, cannot update installation path")])
            path = None

        if path is not None:
            installs = Program_Data.fetch_installs()
            installs["valorant-rpc"] = path
            Program_Data.modify_isntalls(installs)


    @staticmethod
    def fetch_installs():
        try:
            with open(Program_Data.installs_path) as f:
                installs = json.load(f)
                return installs
        except:
            return Program_Data.create_installs_file()

    @staticmethod
    def modify_isntalls(payload):
        with open(Program_Data.installs_path, "w") as f:
            json.dump(payload, f)

        return Program_Data.fetch_installs()

    @staticmethod
    def create_installs_file():
        with open(Program_Data.installs_path, "w") as f:
            payload = {}
            json.dump(payload, f)

        return Program_Data.fetch_installs()

    @staticmethod
    def check_for_folder():
        programdata_folder = Filepath.get_programdata_folder()
        if not os.path.isdir(programdata_folder):
            os.makedirs(programdata_folder)

--- .\presets\valorant\src\utilities\rcs.py ---

import os, json

class Riot_Client_Services:

    @staticmethod 
    def get_rcs_path():
        riot_installs_path = os.path.expandvars("%PROGRAMDATA%\\Riot Games\\RiotClientInstalls.json")
        try:
            with open(riot_installs_path, "r") as file:
                client_installs = json.load(file)
                rcs_path = os.path.abspath(client_installs["rc_default"])
                if not os.access(rcs_path, os.X_OK):
                    return None
                return rcs_path
        except FileNotFoundError:
            return None
    

--- .\presets\valorant\src\utilities\systray.py ---

from PIL import Image
from pystray import Icon as icon, Menu as menu, MenuItem as item
import ctypes, os, urllib.request, sys, time, pyperclip
from InquirerPy.utils import color_print

from .filepath import Filepath
from .config.modify_config import Config_Editor
from ..localization.localization import Localizer
from ..presence.presence_utilities import Utilities

kernel32 = ctypes.WinDLL('kernel32')
user32 = ctypes.WinDLL('user32')
hWnd = kernel32.GetConsoleWindow()

window_shown = False


class Systray:

    def __init__(self, client, config):
        self.client = client
        self.config = config

    def run(self):
        global window_shown
        Systray.generate_icon()
        systray_image = Image.open(Filepath.get_path(os.path.join(Filepath.get_appdata_folder(), 'favicon.ico')))
        systray_menu = menu(
            item('show window', Systray.tray_window_toggle, checked=lambda item: window_shown),
            item('config', Systray.modify_config),
            #item('copy join link', self.copy_join_link),
            item('reload', Systray.restart),
            item('exit', self.exit)
        )
        self.systray = icon("valorant-rpc", systray_image, "valorant-rpc", systray_menu)
        self.systray.run()

    def exit(self):
        self.systray.visible = False
        self.systray.stop()
        try:
            os._exit(1)
        except:
            pass

    def copy_join_link(self):
        pyperclip.copy(Utilities.get_join_state(self.client,self.config)[0]["url"])

    @staticmethod
    def generate_icon():
        urllib.request.urlretrieve('https://raw.githubusercontent.com/colinhartigan/valorant-rpc/v2/favicon.ico',Filepath.get_path(os.path.join(Filepath.get_appdata_folder(),'favicon.ico')))

    @staticmethod 
    def modify_config():
        #user32.ShowWindow(hWnd, 1)
        Config_Editor()
        if not window_shown:
            color_print([("LimeGreen",f"{Localizer.get_localized_text('prints','systray','hiding_window')}\n")])
            time.sleep(1)
            #user32.ShowWindow(hWnd, 0)

    @staticmethod
    def restart():
        #user32.ShowWindow(hWnd, 1)
        os.system('cls' if os.name == 'nt' else 'clear')
        os.execl(sys.executable, os.path.abspath(__file__), *sys.argv) 

    @staticmethod
    def tray_window_toggle(icon,item):
        global window_shown
        try:
            window_shown = not item.checked
            if window_shown:
                user32.ShowWindow(hWnd, 1)
            else:
                user32.ShowWindow(hWnd, 0)
        except Exception as e:
            pass # oh no! bad python practices! 

--- .\presets\valorant\src\utilities\version_checker.py ---

import requests 
from InquirerPy.utils import color_print

from ..localization.localization import Localizer

class Checker:
    @staticmethod 
    def check_version(config):
        try:
            current_version = Localizer.get_config_value("version")
            data = requests.get("https://api.github.com/repos/colinhartigan/valorant-rpc/releases/latest")
            latest = data.json()["tag_name"]
            if latest != current_version:
                color_print([("Yellow bold",f"({current_version} -> {latest}) {Localizer.get_localized_text('prints','version_checker','update_available')} "),("Cyan underline",f"https://github.com/colinhartigan/valorant-rpc/releases/tag/{latest}")])
        except:
            color_print([("Yellow bold",Localizer.get_localized_text("prints","version_checker","checker_error"))])


--- .\presets\valorant\src\utilities\config\app_config.py ---

import json, os
from valclient.client import Client 

from ..filepath import Filepath

from ...localization.locales import Locales
from ...localization.localization import Localizer

default_config = {
    "version": "v3.2.3",
    "region": ["",Client.fetch_regions()],
    "client_id": 811469787657928704,
    "presence_refresh_interval": 3,
    "locale": ["",[locale for locale,data in Locales.items() if data != {}]],
    "presences": {
        "menu": {
            "show_rank_in_comp_lobby": True,
            #"show_join_button_with_open_party": True,
            #"allow_join_requests": False,
        },
        "modes": {
            "all": {
                "small_image": ["agent",["rank","agent","map"]],
                "large_image": ["map",["rank","agent","map"]],
            },
            "range": {
                "show_rank_in_range": False,
            }
        }
    },
    "startup": {
        "game_launch_timeout": 50,
        "presence_timeout": 60,
        "show_github_link": True,
        "auto_launch_skincli": True,
    },
}

class Config:

    @staticmethod
    def fetch_config():
        try:
            with open(Filepath.get_path(os.path.join(Filepath.get_appdata_folder(), "config.json"))) as f:
                config = json.load(f)
                return config
        except:
            return Config.create_default_config()

    @staticmethod
    def modify_config(new_config):
        with open(Filepath.get_path(os.path.join(Filepath.get_appdata_folder(), "config.json")), "w") as f:
            json.dump(new_config, f)

        return Config.fetch_config()

    @staticmethod
    def check_config():
        # ???????
        # my brain hurts
        # i bet theres a way better way to write this but im just braindead
        config = Config.fetch_config()
        unlocalized_config = Config.localize_config(config,True)
        
        def check_for_new_vars(blank,current):
            for key,value in blank.items():
                if not key in current.keys():
                    current[key] = value
                if type(value) != type(current[key]):
                    # if type of option is changed
                    current[key] = value
                if key == "version": 
                    # version can't be changed by the user lmao
                    current[key] = value
                if key == "region": 
                    current[key][1] = Client.fetch_regions() # update regions jic ya know
                if isinstance(value,list):
                    current[key][0] = current[key][0]
                    current[key][1] = blank[key][1]
                    if not current[key][0] in blank[key][1]:
                        current[key][0] = blank[key][0]
                if isinstance(value,dict):
                    check_for_new_vars(value,current[key])
            return current
            
        def remove_unused_vars(blank,current):
            def check(bl,cur):
                for key,value in list(cur.items()):
                    if not key in bl.keys():
                        del cur[key]
                    if isinstance(value,dict) and key in list(cur.keys()):
                        check(bl[key],value)

            check(blank,current)
            return current

        unlocalized_config = check_for_new_vars(default_config,unlocalized_config)
        unlocalized_config = remove_unused_vars(default_config,unlocalized_config)
        config = Config.localize_config(unlocalized_config)
        Config.modify_config(config)
        return config


    @staticmethod
    def localize_config(config,unlocalize=False):
        def check(blank,current):
            for key,value in list(blank.items() if not unlocalize else current.items()):
                new_key = Localizer.get_config_key(key) if not unlocalize else Localizer.unlocalize_key(key)
                if new_key != key:
                    if unlocalize:
                        current[new_key] = current[key]
                        del current[key]
                    else:
                        #print(current[key])
                        current[new_key] = current[key]
                        del current[key]

                if isinstance(value,list):
                    if not unlocalize:
                        new_options = [Localizer.get_config_key(x) for x in value[1]]
                        current[new_key][0] = Localizer.get_config_key(current[new_key][0])
                        current[new_key][1] = new_options

                    else:
                        new_options = [Localizer.unlocalize_key(x) for x in value[1]]
                        unlocalized = Localizer.unlocalize_key(current[new_key][0])
                        value[0] = unlocalized
                        value[1] = new_options
                
                if isinstance(value,dict):
                    check(value,current[new_key])

        check(default_config,config)
        return config

    @staticmethod
    def create_default_config():
        if not os.path.exists(Filepath.get_appdata_folder()):
            os.mkdir(Filepath.get_appdata_folder())
        with open(Filepath.get_path(os.path.join(Filepath.get_appdata_folder(), "config.json")), "w") as f:
            json.dump(default_config, f)
        return Config.fetch_config()


--- .\presets\valorant\src\utilities\config\modify_config.py ---

from InquirerPy.utils import color_print
from InquirerPy import inquirer
from valclient.client import Client

from .app_config import Config
from ...localization.localization import Localizer


class Config_Editor:

    # my friends made me listen to alvin and the chipmunks music
    # while writing this so i apologize for how poorly its written

    def __init__(self):
        self.config = Config.fetch_config()

        self.config_menu("main", self.config)

    def config_menu(self, section, choices, callback=None, callback_args=None):
        # recursion makes me want to die but its for a good cause

        prompt_choices = [
            {"name": f"{setting}" + ( f" ({value[0]})" if isinstance(value, list) else f" ({value})" if not isinstance(value, dict) else " (>>)"), "value": setting} for
            setting, value in choices.items()
        ]
        prompt_choices.insert(0, {"name": "back" if section != "main" else "done", "value": "back"} )

        choice = inquirer.select(
            message=f"[{section}] {Localizer.get_localized_text('prints','config_modification','select_option')}",
            choices=prompt_choices,
            pointer=">"
        )
        choice = choice.execute()

        if choice == "back":
            if section != "main":
                callback(*callback_args)
            elif callback is None:
                Config.modify_config(self.config)
                color_print([("LimeGreen", Localizer.get_localized_text("prints","config_modification","config_saved"))])
                return
        else:
            if isinstance(choices[choice], dict):
                self.config_menu(choice, choices[choice], callback=self.config_menu,callback_args=(section, choices, callback, callback_args))
            else:
                if choice == Localizer.get_config_key("locale"): 
                    #translate config
                    old_locale = choices[choice]
                    new_locale = self.config_set(choice, choices[choice])[0]
                    self.config = Config.localize_config(self.config,True)
                    self.config["locale"][0] = new_locale
                    Localizer.locale = new_locale
                    self.config = Config.localize_config(self.config,False)
                    Localizer.config = self.config
                else:
                    choices[choice] = self.config_set(choice, choices[choice])

                self.config_menu(section, choices, callback, callback_args)

    @staticmethod
    def config_set(name, option):
        if type(option) is str:
            choice = inquirer.text(
                message=f"{Localizer.get_localized_text('prints','config_modification','set_prompt')} {name} (expecting str)",
                default=str(option),
                validate=lambda result: not result.isdigit(),
                filter=lambda result: str(result)
            )
            choice = choice.execute()
            return choice

        if type(option) is int:
            choice = inquirer.text(
                message=f"{Localizer.get_localized_text('prints','config_modification','set_prompt')} {name} (expecting int)",
                default=str(option),
                validate=lambda result: result.isdigit(),
                filter=lambda result: int(result)
            )
            choice = choice.execute()
            return choice

        if type(option) is bool:
            choice = inquirer.select(
                message=f"{Localizer.get_localized_text('prints','config_modification','set_prompt')} {name}",
                default=option,
                choices=[{"name": "true", "value": True},
                         {"name": "false", "value": False}],
                pointer=">"
            )
            choice = choice.execute()
            return choice

        if type(option) is list:
            current = option[0]
            options = option[1]
            choice = inquirer.select(
                message=f"{Localizer.get_localized_text('prints','config_modification','set_prompt')} {name}",
                default=current,
                choices={option:option for option in options},
                pointer=">"
            )
            choice = choice.execute()
            option[0] = choice 
            return option

--- .\presets\valorant\src\webserver\server.py ---

from flask import Flask, request, cli, jsonify, Response
from flask_cors import CORS
import urllib3, logging

urllib3.disable_warnings()
app = Flask(__name__)
CORS(app)
cli.show_server_banner = lambda *_: None
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

# a not-so-rich discord invite system

client = None 
config = None

@app.route('/')
def home():
    return 'ok'


@app.route('/valorant/request/<party_id>/<friend_id>')
def request_party(party_id,friend_id):
    region = request.args.get('region')
    if region == client.region:
        data = client.party_request_to_join(party_id,friend_id)
        for player in data["Requests"]:
            if client.puuid == player["RequestedBySubject"]:
                return "<script>window.onload = window.close();</script>"
        return data
    else:
        return f"you're not in the right region! (their region: {region}, your region: {client.region})"

@app.route('/valorant/join/<party_id>')
def join_party(party_id):
    region = request.args.get('region')
    if region == client.region:
        data = client.party_join(party_id)
        if "CurrentPartyID" in data.keys():
            return "<script>window.onload = window.close();</script>"
        return data

    return f"you're not in the right region! (their region: {region}, your region: {client.region})"


def start():
    app.run(port=4100)


